---
title: Built-in Functions
description:
  This document is a reference for the Pact smart-contract language, designed
  for correct, transactional execution on a high-performance blockchain.
menu: Built-in Functions
label: General
order: 6
layout: full
---

# Built-in Functions

## General

### CHARSET_ASCII

Constant denoting the ASCII charset

Constant: &nbsp;&nbsp;`CHARSET_ASCII:integer = 0`

### CHARSET_LATIN1

Constant denoting the Latin-1 charset ISO-8859-1

Constant: &nbsp;&nbsp;`CHARSET_LATIN1:integer = 1`

### at

_idx_&nbsp;`integer` _list_&nbsp;`[<l>]` _&rarr;_&nbsp;`<a>`

_idx_&nbsp;`string` _object_&nbsp;`object:<{o}>` _&rarr;_&nbsp;`<a>`

Index LIST at IDX, or get value with key IDX from OBJECT.

```lisp
pact> (at 1 [1 2 3])
2
pact> (at "bar" { "foo": 1, "bar": 2 })
2
```

### base64-decode

_string_&nbsp;`string` _&rarr;_&nbsp;`string`

Decode STRING from unpadded base64

```lisp
pact> (base64-decode "aGVsbG8gd29ybGQh")
"hello world!"
```

### base64-encode

_string_&nbsp;`string` _&rarr;_&nbsp;`string`

Encode STRING as unpadded base64

```lisp
pact> (base64-encode "hello world!")
"aGVsbG8gd29ybGQh"
```

### bind

_src_&nbsp;`object:<{row}>` _binding_&nbsp;`binding:<{row}>` _&rarr;_&nbsp;`<a>`

Special form evaluates SRC to an object which is bound to with BINDINGS over
subsequent body statements.

```lisp
pact> (bind { "a": 1, "b": 2 } { "a" := a-value } a-value)
1
```

### chain-data

_&rarr;_&nbsp;`object:{public-chain-data}`

Get transaction public metadata. Returns an object with 'chain-id',
'block-height', 'block-time', 'prev-block-hash', 'sender', 'gas-limit',
'gas-price', and 'gas-fee' fields.

```lisp
pact> (chain-data)
{"block-height": 0,"block-time": "1970-01-01T00:00:00Z","chain-id": "","gas-limit": 0,"gas-price": 0.0,"prev-block-hash": "","sender": ""}
```

### compose

_x_&nbsp;`x:<a> -> <b>` _y_&nbsp;`x:<b> -> <c>` _value_&nbsp;`<a>`
_&rarr;_&nbsp;`<c>`

Compose X and Y, such that X operates on VALUE, and Y on the results of X.

```lisp
pact> (filter (compose (length) (< 2)) ["my" "dog" "has" "fleas"])
["dog" "has" "fleas"]
```

### concat

_str-list_&nbsp;`[string]` _&rarr;_&nbsp;`string`

Takes STR-LIST and concats each of the strings in the list, returning the
resulting string

```lisp
pact> (concat ["k" "d" "a"])
"kda"
pact> (concat (map (+ " ") (str-to-list "abcde")))
" a b c d e"
```

### constantly

_value_&nbsp;`<a>` _ignore1_&nbsp;`<b>` _&rarr;_&nbsp;`<a>`

_value_&nbsp;`<a>` _ignore1_&nbsp;`<b>` _ignore2_&nbsp;`<c>` _&rarr;_&nbsp;`<a>`

_value_&nbsp;`<a>` _ignore1_&nbsp;`<b>` _ignore2_&nbsp;`<c>`
_ignore3_&nbsp;`<d>` _&rarr;_&nbsp;`<a>`

Lazily ignore arguments IGNORE\* and return VALUE.

```lisp
pact> (filter (constantly true) [1 2 3])
[1 2 3]
```

### contains

_value_&nbsp;`<a>` _list_&nbsp;`[<a>]` _&rarr;_&nbsp;`bool`

_key_&nbsp;`<a>` _object_&nbsp;`object:<{o}>` _&rarr;_&nbsp;`bool`

_value_&nbsp;`string` _string_&nbsp;`string` _&rarr;_&nbsp;`bool`

Test that LIST or STRING contains VALUE, or that OBJECT has KEY entry.

```lisp
pact> (contains 2 [1 2 3])
true
pact> (contains 'name { 'name: "Ted", 'age: 72 })
true
pact> (contains "foo" "foobar")
true
```

### continue

_value_&nbsp;`*` _&rarr;_&nbsp;`*`

Continue a previously started nested defpact.

```lisp
(continue (coin.transfer-crosschain "bob" "alice" 10.0))
```

### define-namespace

_namespace_&nbsp;`string` _user-guard_&nbsp;`guard` _admin-guard_&nbsp;`guard`
_&rarr;_&nbsp;`string`

Create a namespace called NAMESPACE where ownership and use of the namespace is
controlled by GUARD. If NAMESPACE is already defined, then the guard previously
defined in NAMESPACE will be enforced, and GUARD will be rotated in its place.

```lisp
(define-namespace 'my-namespace (read-keyset 'user-ks) (read-keyset 'admin-ks))
```

Top level only: this function will fail if used in module code.

### describe-namespace

_ns_&nbsp;`string` _&rarr;_&nbsp;`object:{described-namespace}`

Describe the namespace NS, returning a row object containing the user and admin
guards of the namespace, as well as its name.

```lisp
(describe-namespace 'my-namespace)
```

Top level only: this function will fail if used in module code.

### distinct

_values_&nbsp;`[<a>]` _&rarr;_&nbsp;`[<a>]`

Returns from a homogeneous list of VALUES a list with duplicates removed. The
original order of the values is preserved.

```lisp
pact> (distinct [3 3 1 1 2 2])
[3 1 2]
```

### drop

_count_&nbsp;`integer` _list_&nbsp;`<a[[<l>],string]>`
_&rarr;_&nbsp;`<a[[<l>],string]>`

_keys_&nbsp;`[string]` _object_&nbsp;`object:<{o}>` _&rarr;_&nbsp;`object:<{o}>`

Drop COUNT values from LIST (or string), or entries having keys in KEYS from
OBJECT. If COUNT is negative, drop from end. If COUNT exceeds the interval
(-2^63,2^63), it is truncated to that range.

```lisp
pact> (drop 2 "vwxyz")
"xyz"
pact> (drop (- 2) [1 2 3 4 5])
[1 2 3]
pact> (drop ['name] { 'name: "Vlad", 'active: false})
{"active": false}
```

### enforce

_test_&nbsp;`bool` _msg_&nbsp;`string` _&rarr;_&nbsp;`bool`

Fail transaction with MSG if pure expression TEST is false. Otherwise, returns
true.

```lisp
pact> (enforce (!= (+ 2 2) 4) "Chaos reigns")
<interactive>:0:0:Error: Chaos reigns
```

### enforce-one

_msg_&nbsp;`string` _tests_&nbsp;`[bool]` _&rarr;_&nbsp;`bool`

Run TESTS in order (in pure context, plus keyset enforces). If all fail, fail
transaction. Short-circuits on first success.

```lisp
pact> (enforce-one "Should succeed on second test" [(enforce false "Skip me") (enforce (= (+ 2 2) 4) "Chaos reigns")])
true
```

### enforce-pact-version

_min-version_&nbsp;`string` _&rarr;_&nbsp;`bool`

_min-version_&nbsp;`string` _max-version_&nbsp;`string` _&rarr;_&nbsp;`bool`

Enforce runtime pact version as greater than or equal MIN-VERSION, and less than
or equal MAX-VERSION. Version values are matched numerically from the left, such
that '2', '2.2', and '2.2.3' would all allow '2.2.3'.

```lisp
pact> (enforce-pact-version "2.3")
true
```

Top level only: this function will fail if used in module code.

### enumerate

_from_&nbsp;`integer` _to_&nbsp;`integer` _inc_&nbsp;`integer`
_&rarr;_&nbsp;`[integer]`

_from_&nbsp;`integer` _to_&nbsp;`integer` _&rarr;_&nbsp;`[integer]`

Returns a sequence of numbers from FROM to TO (both inclusive) as a list. INC is
the increment between numbers in the sequence. If INC is not given, it is
assumed to be 1. Additionally, if INC is not given and FROM is greater than TO
assume a value for INC of -1. If FROM equals TO, return the singleton list
containing FROM, irrespective of INC's value. If INC is equal to zero, this
function will return the singleton list containing FROM. If INC is such that
FROM + INC > TO (when FROM < TO) or FROM + INC < TO (when FROM > TO) return the
singleton list containing FROM. Lastly, if INC is such that FROM + INC < TO
(when FROM < TO) or FROM + INC > TO (when FROM > TO), then this function fails.

```lisp
pact> (enumerate 0 10 2)
[0 2 4 6 8 10]
pact> (enumerate 0 10)
[0 1 2 3 4 5 6 7 8 9 10]
pact> (enumerate 10 0)
[10 9 8 7 6 5 4 3 2 1 0]
```

### filter

_app_&nbsp;`x:<a> -> bool` _list_&nbsp;`[<a>]` _&rarr;_&nbsp;`[<a>]`

Filter LIST by applying APP to each element. For each true result, the original
value is kept.

```lisp
pact> (filter (compose (length) (< 2)) ["my" "dog" "has" "fleas"])
["dog" "has" "fleas"]
```

### fold

_app_&nbsp;`x:<a> y:<b> -> <a>` _init_&nbsp;`<a>` _list_&nbsp;`[<b>]`
_&rarr;_&nbsp;`<a>`

Iteratively reduce LIST by applying APP to last result and element, starting
with INIT.

```lisp
pact> (fold (+) 0 [100 10 5])
115
```

### format

_template_&nbsp;`string` _vars_&nbsp;`[*]` _&rarr;_&nbsp;`string`

Interpolate VARS into TEMPLATE using {}.

```lisp
pact> (format "My {} has {}" ["dog" "fleas"])
"My dog has fleas"
```

### hash

_value_&nbsp;`<a>` _&rarr;_&nbsp;`string`

Compute BLAKE2b 256-bit hash of VALUE represented in unpadded base64-url.
Strings are converted directly while other values are converted using their JSON
representation. Non-value-level arguments are not allowed.

```lisp
pact> (hash "hello")
"Mk3PAn3UowqTLEQfNlol6GsXPe-kuOWJSCU0cbgbcs8"
pact> (hash { 'foo: 1 })
"h9BZgylRf_M4HxcBXr15IcSXXXSz74ZC2IAViGle_z4"
```

### identity

_value_&nbsp;`<a>` _&rarr;_&nbsp;`<a>`

Return provided value.

```lisp
pact> (map (identity) [1 2 3])
[1 2 3]
```

### if

_cond_&nbsp;`bool` _then_&nbsp;`<a>` _else_&nbsp;`<a>` _&rarr;_&nbsp;`<a>`

Test COND. If true, evaluate THEN. Otherwise, evaluate ELSE.

```lisp
pact> (if (= (+ 2 2) 4) "Sanity prevails" "Chaos reigns")
"Sanity prevails"
```

### int-to-str

_base_&nbsp;`integer` _val_&nbsp;`integer` _&rarr;_&nbsp;`string`

Represent integer VAL as a string in BASE. BASE can be 2-16, or 64 for unpadded
base64URL. Only positive values are allowed for base64URL conversion.

```lisp
pact> (int-to-str 16 65535)
"ffff"
pact> (int-to-str 64 43981)
"q80"
```

### is-charset

_charset_&nbsp;`integer` _input_&nbsp;`string` _&rarr;_&nbsp;`bool`

Check that a string INPUT conforms to the a supported character set CHARSET.
Character sets currently supported are: 'CHARSET_LATIN1' (ISO-8859-1), and
'CHARSET_ASCII' (ASCII). Support for sets up through ISO 8859-5 supplement will
be added in the future.

```lisp
pact> (is-charset CHARSET_ASCII "hello world")
true
pact> (is-charset CHARSET_ASCII "I am nÖt ascii")
false
pact> (is-charset CHARSET_LATIN1 "I am nÖt ascii, but I am latin1!")
true
```

### length

_x_&nbsp;`<a[[<l>],string,object:<{o}>]>` _&rarr;_&nbsp;`integer`

Compute length of X, which can be a list, a string, or an object.

```lisp
pact> (length [1 2 3])
3
pact> (length "abcdefgh")
8
pact> (length { "a": 1, "b": 2 })
2
```

### list

_elems_&nbsp;`*` _&rarr;_&nbsp;`[*]`

Create list from ELEMS. Deprecated in Pact 2.1.1 with literal list support.

```lisp
pact> (list 1 2 3)
[1 2 3]
```

### list-modules

_&rarr;_&nbsp;`[string]`

List modules available for loading.

Top level only: this function will fail if used in module code.

### make-list

_length_&nbsp;`integer` _value_&nbsp;`<a>` _&rarr;_&nbsp;`[<a>]`

Create list by repeating VALUE LENGTH times.

```lisp
pact> (make-list 5 true)
[true true true true true]
```

### map

_app_&nbsp;`x:<b> -> <a>` _list_&nbsp;`[<b>]` _&rarr;_&nbsp;`[<a>]`

Apply APP to each element in LIST, returning a new list of results.

```lisp
pact> (map (+ 1) [1 2 3])
[2 3 4]
```

### namespace

_namespace_&nbsp;`string` _&rarr;_&nbsp;`string`

Set the current namespace to NAMESPACE. All expressions that occur in a current
transaction will be contained in NAMESPACE, and once committed, may be accessed
via their fully qualified name, which will include the namespace. Subsequent
namespace calls in the same tx will set a new namespace for all declarations
until either the next namespace declaration, or the end of the tx.

```lisp
(namespace 'my-namespace)
```

Top level only: this function will fail if used in module code.

### pact-id

_&rarr;_&nbsp;`string`

Return ID if called during current pact execution, failing if not.

### pact-version

_&rarr;_&nbsp;`string`

Obtain current pact build version.

```lisp
pact> (pact-version)
"4.7.1"
```

Top level only: this function will fail if used in module code.

### public-chain-data

Schema type for data returned from 'chain-data'.

Fields: &nbsp;&nbsp;`chain-id:string` &nbsp;&nbsp;`block-height:integer`
&nbsp;&nbsp;`block-time:time` &nbsp;&nbsp;`prev-block-hash:string`
&nbsp;&nbsp;`sender:string` &nbsp;&nbsp;`gas-limit:integer`
&nbsp;&nbsp;`gas-price:decimal`

### read-decimal

_key_&nbsp;`string` _&rarr;_&nbsp;`decimal`

Parse KEY string or number value from top level of message data body as decimal.

```lisp
(defun exec ()
   (transfer (read-msg "from") (read-msg "to") (read-decimal "amount")))
```

### read-integer

_key_&nbsp;`string` _&rarr;_&nbsp;`integer`

Parse KEY string or number value from top level of message data body as integer.

```lisp
(read-integer "age")
```

### read-msg

_&rarr;_&nbsp;`<a>`

_key_&nbsp;`string` _&rarr;_&nbsp;`<a>`

Read KEY from top level of message data body, or data body itself if not
provided. Coerces value to their corresponding pact type: String -> string,
Number -> integer, Boolean -> bool, List -> list, Object -> object.

```lisp
(defun exec ()
   (transfer (read-msg "from") (read-msg "to") (read-decimal "amount")))
```

### read-string

_key_&nbsp;`string` _&rarr;_&nbsp;`string`

Parse KEY string or number value from top level of message data body as string.

```lisp
(read-string "sender")
```

### remove

_key_&nbsp;`string` _object_&nbsp;`object:<{o}>` _&rarr;_&nbsp;`object:<{o}>`

Remove entry for KEY from OBJECT.

```lisp
pact> (remove "bar" { "foo": 1, "bar": 2 })
{"foo": 1}
```

### resume

_binding_&nbsp;`binding:<{r}>` _&rarr;_&nbsp;`<a>`

Special form binds to a yielded object value from the prior step execution in a
pact. If yield step was executed on a foreign chain, enforce endorsement via
SPV.

### reverse

_list_&nbsp;`[<a>]` _&rarr;_&nbsp;`[<a>]`

Reverse LIST.

```lisp
pact> (reverse [1 2 3])
[3 2 1]
```

### sort

_values_&nbsp;`[<a>]` _&rarr;_&nbsp;`[<a>]`

_fields_&nbsp;`[string]` _values_&nbsp;`[object:<{o}>]`
_&rarr;_&nbsp;`[object:<{o}>]`

Sort a homogeneous list of primitive VALUES, or objects using supplied FIELDS
list.

```lisp
pact> (sort [3 1 2])
[1 2 3]
pact> (sort ['age] [{'name: "Lin",'age: 30} {'name: "Val",'age: 25}])
[{"name": "Val","age": 25} {"name": "Lin","age": 30}]
```

### str-to-int

_str-val_&nbsp;`string` _&rarr;_&nbsp;`integer`

_base_&nbsp;`integer` _str-val_&nbsp;`string` _&rarr;_&nbsp;`integer`

Compute the integer value of STR-VAL in base 10, or in BASE if specified.
STR-VAL can be up to 512 chars in length. BASE must be between 2 and 16, or 64
to perform unpadded base64url conversion. Each digit must be in the correct
range for the base.

```lisp
pact> (str-to-int 16 "abcdef123456")
188900967593046
pact> (str-to-int "123456")
123456
pact> (str-to-int 64 "q80")
43981
```

### str-to-list

_str_&nbsp;`string` _&rarr;_&nbsp;`[string]`

Takes STR and returns a list of single character strings

```lisp
pact> (str-to-list "hello")
["h" "e" "l" "l" "o"]
pact> (concat (map (+ " ") (str-to-list "abcde")))
" a b c d e"
```

### take

_count_&nbsp;`integer` _list_&nbsp;`<a[[<l>],string]>`
_&rarr;_&nbsp;`<a[[<l>],string]>`

_keys_&nbsp;`[string]` _object_&nbsp;`object:<{o}>` _&rarr;_&nbsp;`object:<{o}>`

Take COUNT values from LIST (or string), or entries having keys in KEYS from
OBJECT. If COUNT is negative, take from end. If COUNT exceeds the interval
(-2^63,2^63), it is truncated to that range.

```lisp
pact> (take 2 "abcd")
"ab"
pact> (take (- 3) [1 2 3 4 5])
[3 4 5]
pact> (take ['name] { 'name: "Vlad", 'active: false})
{"name": "Vlad"}
```

### try

_default_&nbsp;`<a>` _action_&nbsp;`<a>` _&rarr;_&nbsp;`<a>`

Attempt a pure ACTION, returning DEFAULT in the case of failure. Pure
expressions are expressions which do not do i/o or work with non-deterministic
state in contrast to impure expressions such as reading and writing to a table.

```lisp
pact> (try 3 (enforce (= 1 2) "this will definitely fail"))
3
(expect "impure expression fails and returns default" "default" (try "default" (with-read accounts id {'ccy := ccy}) ccy))
```

### tx-hash

_&rarr;_&nbsp;`string`

Obtain hash of current transaction as a string.

```lisp
pact> (tx-hash)
"DldRwCblQ7Loqy6wYJnaodHl30d3j3eH-qtFzfEv46g"
```

### typeof

_x_&nbsp;`<a>` _&rarr;_&nbsp;`string`

Returns type of X as string.

```lisp
pact> (typeof "hello")
"string"
```

### where

_field_&nbsp;`string` _app_&nbsp;`x:<a> -> bool` _value_&nbsp;`object:<{row}>`
_&rarr;_&nbsp;`bool`

Utility for use in 'filter' and 'select' applying APP to FIELD in VALUE.

```lisp
pact> (filter (where 'age (> 20)) [{'name: "Mary",'age: 30} {'name: "Juan",'age: 15}])
[{"name": "Juan","age": 15}]
```

### yield

_object_&nbsp;`object:<{y}>` _&rarr;_&nbsp;`object:<{y}>`

_object_&nbsp;`object:<{y}>` _target-chain_&nbsp;`string`
_&rarr;_&nbsp;`object:<{y}>`

Yield OBJECT for use with 'resume' in following pact step. With optional
argument TARGET-CHAIN, target subsequent step to execute on targeted chain using
automated SPV endorsement-based dispatch.

```lisp
(yield { "amount": 100.0 })
(yield { "amount": 100.0 } "some-chain-id")
```

### zip

_f_&nbsp;`x:<a> y:<b> -> <c>` _list1_&nbsp;`[<a>]` _list2_&nbsp;`[<b>]`
_&rarr;_&nbsp;`[<c>]`

Combine two lists with some function f, into a new list, the length of which is
the length of the shortest list.

```lisp
pact> (zip (+) [1 2 3 4] [4 5 6 7])
[5 7 9 11]
pact> (zip (-) [1 2 3 4] [4 5 6])
[-3 -3 -3]
pact> (zip (+) [1 2 3] [4 5 6 7])
[5 7 9]
pact> (zip (lambda (x y) { 'x: x, 'y: y }) [1 2 3 4] [4 5 6 7])
[{"x": 1,"y": 4} {"x": 2,"y": 5} {"x": 3,"y": 6} {"x": 4,"y": 7}]
```

## Database

### create-table

_table_&nbsp;`table:<{row}>` _&rarr;_&nbsp;`string`

Create table TABLE.

```lisp
(create-table accounts)
```

Top level only: this function will fail if used in module code.

### describe-keyset

_keyset_&nbsp;`string` _&rarr;_&nbsp;`object:*`

Get metadata for KEYSET.

Top level only: this function will fail if used in module code.

### describe-module

_module_&nbsp;`string` _&rarr;_&nbsp;`object:*`

Get metadata for MODULE. Returns an object with 'name', 'hash', 'blessed',
'code', and 'keyset' fields.

```lisp
(describe-module 'my-module)
```

Top level only: this function will fail if used in module code.

### describe-table

_table_&nbsp;`table:<{row}>` _&rarr;_&nbsp;`object:*`

Get metadata for TABLE. Returns an object with 'name', 'hash', 'blessed',
'code', and 'keyset' fields.

```lisp
(describe-table accounts)
```

Top level only: this function will fail if used in module code.

### fold-db

_table_&nbsp;`table:<{row}>` _qry_&nbsp;`a:string b:object:<{row}> -> bool`
_consumer_&nbsp;`a:string b:object:<{row}> -> <b>` _&rarr;_&nbsp;`[<b>]`

Select rows from TABLE using QRY as a predicate with both key and value, and
then accumulate results of the query in CONSUMER. Output is sorted by the
ordering of keys.

```lisp
(let*
 ((qry (lambda (k obj) true)) ;; select all rows
  (f (lambda (k obj) [(at 'firstName obj), (at 'b obj)]))
 )
 (fold-db people (qry) (f))
)
```

### insert

_table_&nbsp;`table:<{row}>` _key_&nbsp;`string` _object_&nbsp;`object:<{row}>`
_&rarr;_&nbsp;`string`

Write entry in TABLE for KEY of OBJECT column data, failing if data already
exists for KEY.

```lisp
(insert accounts id { "balance": 0.0, "note": "Created account." })
```

### keylog

_table_&nbsp;`table:<{row}>` _key_&nbsp;`string` _txid_&nbsp;`integer`
_&rarr;_&nbsp;`[object:*]`

Return updates to TABLE for a KEY in transactions at or after TXID, in a list of
objects indexed by txid.

```lisp
(keylog accounts "Alice" 123485945)
```

### keys

_table_&nbsp;`table:<{row}>` _&rarr;_&nbsp;`[string]`

Return all keys in TABLE.

```lisp
(keys accounts)
```

### read

_table_&nbsp;`table:<{row}>` _key_&nbsp;`string` _&rarr;_&nbsp;`object:<{row}>`

_table_&nbsp;`table:<{row}>` _key_&nbsp;`string` _columns_&nbsp;`[string]`
_&rarr;_&nbsp;`object:<{row}>`

Read row from TABLE for KEY, returning database record object, or just COLUMNS
if specified.

```lisp
(read accounts id ['balance 'ccy])
```

### select

_table_&nbsp;`table:<{row}>` _where_&nbsp;`row:object:<{row}> -> bool`
_&rarr;_&nbsp;`[object:<{row}>]`

_table_&nbsp;`table:<{row}>` _columns_&nbsp;`[string]`
_where_&nbsp;`row:object:<{row}> -> bool` _&rarr;_&nbsp;`[object:<{row}>]`

Select full rows or COLUMNS from table by applying WHERE to each row to get a
boolean determining inclusion.

```lisp
(select people ['firstName,'lastName] (where 'name (= "Fatima")))
(select people (where 'age (> 30)))?
```

### txids

_table_&nbsp;`table:<{row}>` _txid_&nbsp;`integer` _&rarr;_&nbsp;`[integer]`

Return all txid values greater than or equal to TXID in TABLE.

```lisp
(txids accounts 123849535)
```

### txlog

_table_&nbsp;`table:<{row}>` _txid_&nbsp;`integer` _&rarr;_&nbsp;`[object:*]`

Return all updates to TABLE performed in transaction TXID.

```lisp
(txlog accounts 123485945)
```

### update

_table_&nbsp;`table:<{row}>` _key_&nbsp;`string` _object_&nbsp;`object:~<{row}>`
_&rarr;_&nbsp;`string`

Write entry in TABLE for KEY of OBJECT column data, failing if data does not
exist for KEY.

```lisp
(update accounts id { "balance": (+ bal amount), "change": amount, "note": "credit" })
```

### with-default-read

_table_&nbsp;`table:<{row}>` _key_&nbsp;`string`
_defaults_&nbsp;`object:~<{row}>` _bindings_&nbsp;`binding:~<{row}>`
_&rarr;_&nbsp;`<a>`

Special form to read row from TABLE for KEY and bind columns per BINDINGS over
subsequent body statements. If row not found, read columns from DEFAULTS, an
object with matching key names.

```lisp
(with-default-read accounts id { "balance": 0, "ccy": "USD" } { "balance":= bal, "ccy":= ccy }
  (format "Balance for {} is {} {}" [id bal ccy]))
```

### with-read

_table_&nbsp;`table:<{row}>` _key_&nbsp;`string`
_bindings_&nbsp;`binding:<{row}>` _&rarr;_&nbsp;`<a>`

Special form to read row from TABLE for KEY and bind columns per BINDINGS over
subsequent body statements.

```lisp
(with-read accounts id { "balance":= bal, "ccy":= ccy }
  (format "Balance for {} is {} {}" [id bal ccy]))
```

### write

_table_&nbsp;`table:<{row}>` _key_&nbsp;`string` _object_&nbsp;`object:<{row}>`
_&rarr;_&nbsp;`string`

Write entry in TABLE for KEY of OBJECT column data.

```lisp
(write accounts id { "balance": 100.0 })
```

## Time

### add-time

_time_&nbsp;`time` _seconds_&nbsp;`decimal` _&rarr;_&nbsp;`time`

_time_&nbsp;`time` _seconds_&nbsp;`integer` _&rarr;_&nbsp;`time`

Add SECONDS to TIME; SECONDS can be integer or decimal.

```lisp
pact> (add-time (time "2016-07-22T12:00:00Z") 15)
"2016-07-22T12:00:15Z"
```

### days

_n_&nbsp;`decimal` _&rarr;_&nbsp;`decimal`

_n_&nbsp;`integer` _&rarr;_&nbsp;`decimal`

N days, for use with 'add-time'

```lisp
pact> (add-time (time "2016-07-22T12:00:00Z") (days 1))
"2016-07-23T12:00:00Z"
```

### diff-time

_time1_&nbsp;`time` _time2_&nbsp;`time` _&rarr;_&nbsp;`decimal`

Compute difference between TIME1 and TIME2 in seconds.

```lisp
pact> (diff-time (parse-time "%T" "16:00:00") (parse-time "%T" "09:30:00"))
23400.0
```

### format-time

_format_&nbsp;`string` _time_&nbsp;`time` _&rarr;_&nbsp;`string`

Format TIME using FORMAT. See
["Time Formats" docs](pact-reference.html#time-formats) for supported formats.

```lisp
pact> (format-time "%F" (time "2016-07-22T12:00:00Z"))
"2016-07-22"
```

### hours

_n_&nbsp;`decimal` _&rarr;_&nbsp;`decimal`

_n_&nbsp;`integer` _&rarr;_&nbsp;`decimal`

N hours, for use with 'add-time'

```lisp
pact> (add-time (time "2016-07-22T12:00:00Z") (hours 1))
"2016-07-22T13:00:00Z"
```

### minutes

_n_&nbsp;`decimal` _&rarr;_&nbsp;`decimal`

_n_&nbsp;`integer` _&rarr;_&nbsp;`decimal`

N minutes, for use with 'add-time'.

```lisp
pact> (add-time (time "2016-07-22T12:00:00Z") (minutes 1))
"2016-07-22T12:01:00Z"
```

### parse-time

_format_&nbsp;`string` _utcval_&nbsp;`string` _&rarr;_&nbsp;`time`

Construct time from UTCVAL using FORMAT. See
["Time Formats" docs](pact-reference.html#time-formats) for supported formats.

```lisp
pact> (parse-time "%F" "2016-09-12")
"2016-09-12T00:00:00Z"
```

### time

_utcval_&nbsp;`string` _&rarr;_&nbsp;`time`

Construct time from UTCVAL using ISO8601 format (%Y-%m-%dT%H:%M:%SZ).

```lisp
pact> (time "2016-07-22T11:26:35Z")
"2016-07-22T11:26:35Z"
```

## Operators

### !=

_x_&nbsp;`<a[integer,string,time,decimal,bool,[<l>],object:<{o}>,keyset,guard,module{}]>`
_y_&nbsp;`<a[integer,string,time,decimal,bool,[<l>],object:<{o}>,keyset,guard,module{}]>`
_&rarr;_&nbsp;`bool`

True if X does not equal Y.

```lisp
pact> (!= "hello" "goodbye")
true
```

### &

_x_&nbsp;`integer` _y_&nbsp;`integer` _&rarr;_&nbsp;`integer`

Compute bitwise X and Y.

```lisp
pact> (& 2 3)
2
pact> (& 5 -7)
1
```

### \*

_x_&nbsp;`<a[integer,decimal]>` _y_&nbsp;`<a[integer,decimal]>`
_&rarr;_&nbsp;`<a[integer,decimal]>`

_x_&nbsp;`<a[integer,decimal]>` _y_&nbsp;`<b[integer,decimal]>`
_&rarr;_&nbsp;`decimal`

Multiply X by Y.

```lisp
pact> (* 0.5 10.0)
5.0
pact> (* 3 5)
15
```

### \+

_x_&nbsp;`<a[integer,decimal]>` _y_&nbsp;`<a[integer,decimal]>`
_&rarr;_&nbsp;`<a[integer,decimal]>`

_x_&nbsp;`<a[integer,decimal]>` _y_&nbsp;`<b[integer,decimal]>`
_&rarr;_&nbsp;`decimal`

_x_&nbsp;`<a[string,[<l>],object:<{o}>]>`
_y_&nbsp;`<a[string,[<l>],object:<{o}>]>`
_&rarr;_&nbsp;`<a[string,[<l>],object:<{o}>]>`

Add numbers, concatenate strings/lists, or merge objects.

```lisp
pact> (+ 1 2)
3
pact> (+ 5.0 0.5)
5.5
pact> (+ "every" "body")
"everybody"
pact> (+ [1 2] [3 4])
[1 2 3 4]
pact> (+ { "foo": 100 } { "foo": 1, "bar": 2 })
{"bar": 2,"foo": 100}
```

### \-

_x_&nbsp;`<a[integer,decimal]>` _y_&nbsp;`<a[integer,decimal]>`
_&rarr;_&nbsp;`<a[integer,decimal]>`

_x_&nbsp;`<a[integer,decimal]>` _y_&nbsp;`<b[integer,decimal]>`
_&rarr;_&nbsp;`decimal`

_x_&nbsp;`<a[integer,decimal]>` _&rarr;_&nbsp;`<a[integer,decimal]>`

Negate X, or subtract Y from X.

```lisp
pact> (- 1.0)
-1.0
pact> (- 3 2)
1
```

### /

_x_&nbsp;`<a[integer,decimal]>` _y_&nbsp;`<a[integer,decimal]>`
_&rarr;_&nbsp;`<a[integer,decimal]>`

_x_&nbsp;`<a[integer,decimal]>` _y_&nbsp;`<b[integer,decimal]>`
_&rarr;_&nbsp;`decimal`

Divide X by Y.

```lisp
pact> (/ 10.0 2.0)
5.0
pact> (/ 8 3)
2
```

### \<

_x_&nbsp;`<a[integer,decimal,string,time]>`
_y_&nbsp;`<a[integer,decimal,string,time]>` _&rarr;_&nbsp;`bool`

True if X < Y.

```lisp
pact> (< 1 3)
true
pact> (< 5.24 2.52)
false
pact> (< "abc" "def")
true
```

### \<=

_x_&nbsp;`<a[integer,decimal,string,time]>`
_y_&nbsp;`<a[integer,decimal,string,time]>` _&rarr;_&nbsp;`bool`

True if X \<= Y.

```pact
pact> (<= 1 3)
true
pact> (<= 5.24 2.52)
false
pact> (<= "abc" "def")
true
```

### \=

_x_&nbsp;`<a[integer,string,time,decimal,bool,[<l>],object:<{o}>,keyset,guard,module{}]>`
_y_&nbsp;`<a[integer,string,time,decimal,bool,[<l>],object:<{o}>,keyset,guard,module{}]>`
_&rarr;_&nbsp;`bool`

Compare alike terms for equality, returning TRUE if X is equal to Y. Equality
comparisons will fail immediately on type mismatch, or if types are not value
types.

```lisp
pact> (= [1 2 3] [1 2 3])
true
pact> (= 'foo "foo")
true
pact> (= { 'a: 2 } { 'a: 2})
true
```

### >

_x_&nbsp;`<a[integer,decimal,string,time]>`
_y_&nbsp;`<a[integer,decimal,string,time]>` _&rarr;_&nbsp;`bool`

True if X > Y.

```lisp
pact> (> 1 3)
false
pact> (> 5.24 2.52)
true
pact> (> "abc" "def")
false
```

### >=

_x_&nbsp;`<a[integer,decimal,string,time]>`
_y_&nbsp;`<a[integer,decimal,string,time]>` _&rarr;_&nbsp;`bool`

True if X >= Y.

```lisp
pact> (>= 1 3)
false
pact> (>= 5.24 2.52)
true
pact> (>= "abc" "def")
false
```

### ^

_x_&nbsp;`<a[integer,decimal]>` _y_&nbsp;`<a[integer,decimal]>`
_&rarr;_&nbsp;`<a[integer,decimal]>`

_x_&nbsp;`<a[integer,decimal]>` _y_&nbsp;`<b[integer,decimal]>`
_&rarr;_&nbsp;`decimal`

Raise X to Y power.

```lisp
pact> (^ 2 3)
8
```

### abs

_x_&nbsp;`decimal` _&rarr;_&nbsp;`decimal`

_x_&nbsp;`integer` _&rarr;_&nbsp;`integer`

Absolute value of X.

```lisp
pact> (abs (- 10 23))
13
```

### and

_x_&nbsp;`bool` _y_&nbsp;`bool` _&rarr;_&nbsp;`bool`

Boolean logic with short-circuit.

```lisp
pact> (and true false)
false
```

### and?

_a_&nbsp;`x:<r> -> bool` _b_&nbsp;`x:<r> -> bool` _value_&nbsp;`<r>`
_&rarr;_&nbsp;`bool`

Apply logical 'and' to the results of applying VALUE to A and B, with
short-circuit.

```lisp
pact> (and? (> 20) (> 10) 15)
false
```

### ceiling

_x_&nbsp;`decimal` _prec_&nbsp;`integer` _&rarr;_&nbsp;`decimal`

_x_&nbsp;`decimal` _&rarr;_&nbsp;`integer`

Rounds up value of decimal X as integer, or to PREC precision as decimal.

```lisp
pact> (ceiling 3.5)
4
pact> (ceiling 100.15234 2)
100.16
```

### dec

_x_&nbsp;`integer` _&rarr;_&nbsp;`decimal`

Cast an integer to a decimal value of integer X as decimal.

```lisp
pact> (dec 3)
3.0
```

### exp

_x_&nbsp;`<a[integer,decimal]>` _&rarr;_&nbsp;`<a[integer,decimal]>`

Exp of X.

```lisp
pact> (round (exp 3) 6)
20.085537
```

### floor

_x_&nbsp;`decimal` _prec_&nbsp;`integer` _&rarr;_&nbsp;`decimal`

_x_&nbsp;`decimal` _&rarr;_&nbsp;`integer`

Rounds down value of decimal X as integer, or to PREC precision as decimal.

```lisp
pact> (floor 3.5)
3
pact> (floor 100.15234 2)
100.15
```

### ln

_x_&nbsp;`<a[integer,decimal]>` _&rarr;_&nbsp;`<a[integer,decimal]>`

Natural log of X.

```lisp
pact> (round (ln 60) 6)
4.094345
```

### log

_x_&nbsp;`<a[integer,decimal]>` _y_&nbsp;`<a[integer,decimal]>`
_&rarr;_&nbsp;`<a[integer,decimal]>`

_x_&nbsp;`<a[integer,decimal]>` _y_&nbsp;`<b[integer,decimal]>`
_&rarr;_&nbsp;`decimal`

Log of Y base X.

```lisp
pact> (log 2 256)
8
```

### mod

_x_&nbsp;`integer` _y_&nbsp;`integer` _&rarr;_&nbsp;`integer`

X modulo Y.

```lisp
pact> (mod 13 8)
5
```

### not

_x_&nbsp;`bool` _&rarr;_&nbsp;`bool`

Boolean not.

```lisp
pact> (not (> 1 2))
true
```

### not?

_app_&nbsp;`x:<r> -> bool` _value_&nbsp;`<r>` _&rarr;_&nbsp;`bool`

Apply logical 'not' to the results of applying VALUE to APP.

```lisp
pact> (not? (> 20) 15)
false
```

### or

_x_&nbsp;`bool` _y_&nbsp;`bool` _&rarr;_&nbsp;`bool`

Boolean logic with short-circuit.

```lisp
pact> (or true false)
true
```

### or?

_a_&nbsp;`x:<r> -> bool` _b_&nbsp;`x:<r> -> bool` _value_&nbsp;`<r>`
_&rarr;_&nbsp;`bool`

Apply logical 'or' to the results of applying VALUE to A and B, with
short-circuit.

```lisp
pact> (or? (> 20) (> 10) 15)
true
```

### round

_x_&nbsp;`decimal` _prec_&nbsp;`integer` _&rarr;_&nbsp;`decimal`

_x_&nbsp;`decimal` _&rarr;_&nbsp;`integer`

Performs Banker's rounding value of decimal X as integer, or to PREC precision
as decimal.

```lisp
pact> (round 3.5)
4
pact> (round 100.15234 2)
100.15
```

### shift

_x_&nbsp;`integer` _y_&nbsp;`integer` _&rarr;_&nbsp;`integer`

Shift X Y bits left if Y is positive, or right by -Y bits otherwise. Right
shifts perform sign extension on signed number types; i.e. they fill the top
bits with 1 if the x is negative and with 0 otherwise.

```lisp
pact> (shift 255 8)
65280
pact> (shift 255 -1)
127
pact> (shift -255 8)
-65280
pact> (shift -255 -1)
-128
```

### sqrt

_x_&nbsp;`<a[integer,decimal]>` _&rarr;_&nbsp;`<a[integer,decimal]>`

Square root of X.

```lisp
pact> (sqrt 25)
5.0
```

### xor

_x_&nbsp;`integer` _y_&nbsp;`integer` _&rarr;_&nbsp;`integer`

Compute bitwise X xor Y.

```lisp
pact> (xor 127 64)
63
pact> (xor 5 -7)
-4
```

### |

_x_&nbsp;`integer` _y_&nbsp;`integer` _&rarr;_&nbsp;`integer`

Compute bitwise X or Y.

```lisp
pact> (| 2 3)
3
pact> (| 5 -7)
-3
```

### ~

_x_&nbsp;`integer` _&rarr;_&nbsp;`integer`

Reverse all bits in X.

```lisp
pact> (~ 15)
-16
```

## Keysets

### define-keyset

_name_&nbsp;`string` _keyset_&nbsp;`string` _&rarr;_&nbsp;`string`

_name_&nbsp;`string` _&rarr;_&nbsp;`string`

Define keyset as NAME with KEYSET, or if unspecified, read NAME from message
payload as keyset, similarly to 'read-keyset'. If keyset NAME already exists,
keyset will be enforced before updating to new value.

```lisp
(define-keyset 'admin-keyset (read-keyset "keyset"))
```

Top level only: this function will fail if used in module code.

### enforce-keyset

_guard_&nbsp;`guard` _&rarr;_&nbsp;`bool`

_keysetname_&nbsp;`string` _&rarr;_&nbsp;`bool`

Execute GUARD, or defined keyset KEYSETNAME, to enforce desired predicate logic.

```lisp
(enforce-keyset 'admin-keyset)
(enforce-keyset row-guard)
```

### keys-2

_count_&nbsp;`integer` _matched_&nbsp;`integer` _&rarr;_&nbsp;`bool`

Keyset predicate function to match at least 2 keys in keyset.

```lisp
pact> (keys-2 3 1)
false
```

### keys-all

_count_&nbsp;`integer` _matched_&nbsp;`integer` _&rarr;_&nbsp;`bool`

Keyset predicate function to match all keys in keyset.

```lisp
pact> (keys-all 3 3)
true
```

### keys-any

_count_&nbsp;`integer` _matched_&nbsp;`integer` _&rarr;_&nbsp;`bool`

Keyset predicate function to match any (at least 1) key in keyset.

```pact
pact> (keys-any 10 1)
true
```

### read-keyset

_key_&nbsp;`string` _&rarr;_&nbsp;`keyset`

Read KEY from message data body as keyset (\{ "keys": KEYLIST, "pred": PREDFUN
\}). PREDFUN should resolve to a keys predicate.

```lisp
(read-keyset "admin-keyset")
```

## Capabilities

### compose-capability

_capability_&nbsp;` -> bool` _&rarr;_&nbsp;`bool`

Specifies and requests grant of CAPABILITY which is an application of a 'defcap'
production, only valid within a (distinct) 'defcap' body, as a way to compose
CAPABILITY with the outer capability such that the scope of the containing
'with-capability' call will "import" this capability. Thus, a call to
'(with-capability (OUTER-CAP) OUTER-BODY)', where the OUTER-CAP defcap calls
'(compose-capability (INNER-CAP))', will result in INNER-CAP being granted in
the scope of OUTER-BODY.

```lisp
(compose-capability (TRANSFER src dest))
```

### emit-event

_capability_&nbsp;` -> bool` _&rarr;_&nbsp;`bool`

Emit CAPABILITY as event without evaluating body of capability. Fails if
CAPABILITY is not @managed or @event.

```lisp
(emit-event (TRANSFER "Bob" "Alice" 12.0))
```

### enforce-guard

_guard_&nbsp;`guard` _&rarr;_&nbsp;`bool`

_keysetname_&nbsp;`string` _&rarr;_&nbsp;`bool`

Execute GUARD, or defined keyset KEYSETNAME, to enforce desired predicate logic.

```lisp
(enforce-guard 'admin-keyset)
(enforce-guard row-guard)
```

### install-capability

_capability_&nbsp;` -> bool` _&rarr;_&nbsp;`string`

Specifies, and provisions install of, a _managed_ CAPABILITY, defined in a
'defcap' in which a '@managed' tag designates a single parameter to be managed
by a specified function. After install, CAPABILITY must still be brought into
scope using 'with-capability', at which time the 'manager function' is invoked
to validate the request. The manager function is of type 'managed:\<p\>
requested:\<p\> -> \<p\>', where '\<p\>' indicates the type of the managed
parameter, such that for '(defcap FOO (bar:string baz:integer) @managed baz
FOO-mgr ...)', the manager function would be '(defun FOO-mgr:integer
(managed:integer requested:integer) ...)'. Any capability matching the 'static'
(non-managed) parameters will cause this function to be invoked with the current
managed value and that of the requested capability. The function should perform
whatever logic, presumably linear, to validate the request, and return the new
managed value representing the 'balance' of the request. NOTE that signatures
scoped to a managed capability cause the capability to be automatically
provisioned for install similarly to one installed with this function.

```lisp
(install-capability (PAY "alice" "bob" 10.0))
```

### require-capability

_capability_&nbsp;` -> bool` _&rarr;_&nbsp;`bool`

Specifies and tests for existing grant of CAPABILITY, failing if not found in
environment.

```lisp
(require-capability (TRANSFER src dest))
```

### with-capability

_capability_&nbsp;` -> bool` _body_&nbsp;`[*]` _&rarr;_&nbsp;`<a>`

Specifies and requests grant of _acquired_ CAPABILITY which is an application of
a 'defcap' production. Given the unique token specified by this application,
ensure that the token is granted in the environment during execution of BODY.
'with-capability' can only be called in the same module that declares the
corresponding 'defcap', otherwise module-admin rights are required. If token is
not present, the CAPABILITY is evaluated, with successful completion resulting
in the installation/granting of the token, which will then be revoked upon
completion of BODY. Nested 'with-capability' calls for the same token will
detect the presence of the token, and will not re-apply CAPABILITY, but simply
execute BODY. 'with-capability' cannot be called from within an evaluating
defcap. Acquire of a managed capability results in emission of the equivalent
event.

```lisp
(with-capability (UPDATE-USERS id) (update users id { salary: new-salary }))
```

## SPV

### verify-spv

_type_&nbsp;`string` _payload_&nbsp;`object:<in>` _&rarr;_&nbsp;`object:<out>`

Performs a platform-specific spv proof of type TYPE on PAYLOAD. The format of
the PAYLOAD object depends on TYPE, as does the format of the return object.
Platforms such as Chainweb will document the specific payload types and return
values.

```lisp
(verify-spv "TXOUT" (read-msg "proof"))
```

## Commitments

### decrypt-cc20p1305

_ciphertext_&nbsp;`string` _nonce_&nbsp;`string` _aad_&nbsp;`string`
_mac_&nbsp;`string` _public-key_&nbsp;`string` _secret-key_&nbsp;`string`
_&rarr;_&nbsp;`string`

Perform decryption of CIPHERTEXT using the CHACHA20-POLY1305 Authenticated
Encryption with Associated Data (AEAD) construction described in IETF RFC 7539.
CIPHERTEXT is an unpadded base64url string. NONCE is a 12-byte base64 string.
AAD is base64 additional authentication data of any length. MAC is the
"detached" base64 tag value for validating POLY1305 authentication. PUBLIC-KEY
and SECRET-KEY are base-16 Curve25519 values to form the DH symmetric key.Result
is unpadded base64URL.

```lisp
(decrypt-cc20p1305 ciphertext nonce aad mac pubkey privkey)
```

### validate-keypair

_public_&nbsp;`string` _secret_&nbsp;`string` _&rarr;_&nbsp;`bool`

Enforce that the Curve25519 keypair of (PUBLIC,SECRET) match. Key values are
base-16 strings of length 32.

```lisp
(validate-keypair pubkey privkey)
```

## Guards

### create-capability-guard

_capability_&nbsp;` -> bool` _&rarr;_&nbsp;`guard`

Creates a guard that will enforce that CAPABILITY is acquired.

```lisp
(create-capability-guard (BANK_DEBIT 10.0))
```

### create-capability-pact-guard

_capability_&nbsp;` -> bool` _&rarr;_&nbsp;`guard`

Creates a guard that will enforce that CAPABILITY is acquired and that the
currently-executing defpact is operational.

```lisp
(create-capability-pact-guard (ESCROW owner))
```

### create-module-guard

_name_&nbsp;`string` _&rarr;_&nbsp;`guard`

Defines a guard by NAME that enforces the current module admin predicate.

### create-pact-guard

_name_&nbsp;`string` _&rarr;_&nbsp;`guard`

Defines a guard predicate by NAME that captures the results of 'pact-id'. At
enforcement time, the success condition is that at that time 'pact-id' must
return the same value. In effect this ensures that the guard will only succeed
within the multi-transaction identified by the pact id.

### create-principal

_guard_&nbsp;`guard` _&rarr;_&nbsp;`string`

Create a principal which unambiguously identifies GUARD.

```lisp
(create-principal (read-keyset 'keyset))
(create-principal (keyset-ref-guard 'keyset))
(create-principal (create-module-guard 'module-guard))
(create-principal (create-user-guard 'user-guard))
(create-principal (create-pact-guard 'pact-guard))
```

### create-user-guard

_closure_&nbsp;` -> bool` _&rarr;_&nbsp;`guard`

Defines a custom guard CLOSURE whose arguments are strictly evaluated at
definition time, to be supplied to indicated function at enforcement time.

### is-principal

_principal_&nbsp;`string` _&rarr;_&nbsp;`bool`

Tell whether PRINCIPAL string conforms to the principal format without proving
validity.

```lisp
(enforce   (is-principal 'k:462e97a099987f55f6a2b52e7bfd52a36b4b5b470fed0816a3d9b26f9450ba69)   "Invalid account structure: non-principal account")
```

### keyset-ref-guard

_keyset-ref_&nbsp;`string` _&rarr;_&nbsp;`guard`

Creates a guard for the keyset registered as KEYSET-REF with 'define-keyset'.
Concrete keysets are themselves guard types; this function is specifically to
store references alongside other guards in the database, etc.

### typeof-principal

_principal_&nbsp;`string` _&rarr;_&nbsp;`string`

Return the protocol type of a given PRINCIPAL value. If input value is not a
principal type, then the empty string is returned.

```lisp
(typeof-principal 'k:462e97a099987f55f6a2b52e7bfd52a36b4b5b470fed0816a3d9b26f9450ba69)
```

### validate-principal

_guard_&nbsp;`guard` _principal_&nbsp;`string` _&rarr;_&nbsp;`bool`

Validate that PRINCIPAL unambiguously identifies GUARD.

```lisp
(enforce (validate-principal (read-keyset 'keyset) account) "Invalid account ID")
```

## Zk

### pairing-check

_points-g1_&nbsp;`[<a>]` _points-g2_&nbsp;`[<b>]` _&rarr;_&nbsp;`bool`

Perform pairing and final exponentiation points in G1 and G2 in BN254, check if
the result is 1

### point-add

_type_&nbsp;`string` _point1_&nbsp;`<a>` _point2_&nbsp;`<a>` _&rarr;_&nbsp;`<a>`

Add two points together that lie on the curve BN254. Point addition either in Fq
or in Fq2

```lisp
pact> (point-add 'g1 {'x: 1, 'y: 2}  {'x: 1, 'y: 2})
{"x": 1368015179489954701390400359078579693043519447331113978918064868415326638035,"y": 9918110051302171585080402603319702774565515993150576347155970296011118125764}
```

### scalar-mult

_type_&nbsp;`string` _point1_&nbsp;`<a>` _scalar_&nbsp;`integer`
_&rarr;_&nbsp;`<a>`

Multiply a point that lies on the curve BN254 by an integer value

```lisp
pact> (scalar-mult 'g1 {'x: 1, 'y: 2} 2)
{"x": 1368015179489954701390400359078579693043519447331113978918064868415326638035,"y": 9918110051302171585080402603319702774565515993150576347155970296011118125764}
```

## REPL-only functions

The following functions are loaded automatically into the interactive REPL, or
within script files with a `.repl` extension. They are not available for
blockchain-based execution.

### begin-tx

_&rarr;_&nbsp;`string`

_name_&nbsp;`string` _&rarr;_&nbsp;`string`

Begin transaction with optional NAME.

```lisp
pact> (begin-tx "load module")
"Begin Tx 0: load module"
```

### bench

_exprs_&nbsp;`*` _&rarr;_&nbsp;`string`

Benchmark execution of EXPRS.

```lisp
(bench (+ 1 2))
```

### commit-tx

_&rarr;_&nbsp;`string`

Commit transaction.

```lisp
pact> (begin-tx) (commit-tx)
"Commit Tx 0"
```

### continue-pact

_step_&nbsp;`integer` _&rarr;_&nbsp;`string`

_step_&nbsp;`integer` _rollback_&nbsp;`bool` _&rarr;_&nbsp;`string`

_step_&nbsp;`integer` _rollback_&nbsp;`bool` _pact-id_&nbsp;`string`
_&rarr;_&nbsp;`string`

_step_&nbsp;`integer` _rollback_&nbsp;`bool` _pact-id_&nbsp;`string`
_yielded_&nbsp;`object:<{y}>` _&rarr;_&nbsp;`string`

Continue previously-initiated pact identified STEP, optionally specifying
ROLLBACK (default is false), PACT-ID of the pact to be continued (defaults to
the pact initiated in the current transaction, if one is present), and YIELDED
value to be read with 'resume' (if not specified, uses yield in most recent pact
exec, if any).

```lisp
(continue-pact 1)
(continue-pact 1 true)
(continue-pact 1 false "[pact-id-hash]"))
(continue-pact 2 1 false "[pact-id-hash]" { "rate": 0.9 })
```

### env-chain-data

_new-data_&nbsp;`object:~{public-chain-data}` _&rarr;_&nbsp;`string`

Update existing entries of 'chain-data' with NEW-DATA, replacing those items
only.

```lisp
pact> (env-chain-data { "chain-id": "TestNet00/2", "block-height": 20 })
"Updated public metadata"
```

### env-data

_json_&nbsp;`<a[integer,string,time,decimal,bool,[<l>],object:<{o}>,keyset]>`
_&rarr;_&nbsp;`string`

Set transaction JSON data, either as encoded string, or as pact types coerced to
JSON.

```lisp
pact> (env-data { "keyset": { "keys": ["my-key" "admin-key"], "pred": "keys-any" } })
"Setting transaction data"
```

### env-dynref

_iface_&nbsp;`module` _impl_&nbsp;`module{}` _&rarr;_&nbsp;`string`

_&rarr;_&nbsp;`string`

Substitute module IMPL in any dynamic usages of IFACE in typechecking and
analysis. With no arguments, remove all substitutions.

```lisp
(env-dynref fungible-v2 coin)
```

### env-enable-repl-natives

_enable_&nbsp;`bool` _&rarr;_&nbsp;`string`

Control whether REPL native functions are allowed in module code. When enabled,
fixture functions like 'env-sigs' are allowed in module code.

```lisp
pact> (env-enable-repl-natives true)
"Repl natives enabled"
```

### env-entity

_&rarr;_&nbsp;`string`

_entity_&nbsp;`string` _&rarr;_&nbsp;`string`

Set environment confidential ENTITY id, or unset with no argument.

```lisp
(env-entity "my-org")
(env-entity)
```

### env-events

_clear_&nbsp;`bool` _&rarr;_&nbsp;`[object:*]`

Retreive any accumulated events and optionally clear event state. Object
returned has fields 'name' (fully-qualified event name), 'params' (event
parameters), 'module-hash' (hash of emitting module).

```lisp
(env-events true)
```

### env-exec-config

_flags_&nbsp;`[string]` _&rarr;_&nbsp;`[string]`

_&rarr;_&nbsp;`[string]`

Queries, or with arguments, sets execution config flags. Valid flags:
["AllowReadInLocal","DisableHistoryInTransactionalMode","DisableInlineMemCheck","DisableModuleInstall","DisableNewTrans","DisablePact40","DisablePact420","DisablePact43","DisablePact431","DisablePact44","DisablePact45","DisablePact46","DisablePact47","DisablePact48","DisablePactEvents","DisableRuntimeReturnTypeChecking","EnforceKeyFormats","OldReadOnlyBehavior","PreserveModuleIfacesBug","PreserveModuleNameBug","PreserveNsModuleInstallBug","PreserveShowDefs"]

```lisp
pact> (env-exec-config ['DisableHistoryInTransactionalMode]) (env-exec-config)
["DisableHistoryInTransactionalMode"]
```

### env-gas

_&rarr;_&nbsp;`integer`

_gas_&nbsp;`integer` _&rarr;_&nbsp;`string`

Query gas state, or set it to GAS. Note that certain plaforms may charge
additional gas that is not captured by the interpreter gas model, such as an
overall transaction-size cost.

```lisp
pact> (env-gasmodel "table") (env-gaslimit 10) (env-gas 0) (map (+ 1) [1 2 3]) (env-gas)
7
```

### env-gaslimit

_limit_&nbsp;`integer` _&rarr;_&nbsp;`string`

Set environment gas limit to LIMIT.

### env-gaslog

_&rarr;_&nbsp;`string`

Enable and obtain gas logging. Bracket around the code whose gas logs you want
to inspect.

```lisp
pact> (env-gasmodel "table") (env-gaslimit 10) (env-gaslog) (map (+ 1) [1 2 3]) (env-gaslog)
["TOTAL: 7" "map:GUnreduced:currTotalGas=4: 4" "+:GUnreduced:currTotalGas=5: 1" ":GIntegerOpCost:(1, ):(1, ):currTotalGas=5: 0" "+:GUnreduced:currTotalGas=6: 1" ":GIntegerOpCost:(1, ):(2, ):currTotalGas=6: 0" "+:GUnreduced:currTotalGas=7: 1" ":GIntegerOpCost:(1, ):(3, ):currTotalGas=7: 0"]
```

### env-gasmodel

_model_&nbsp;`string` _&rarr;_&nbsp;`string`

_&rarr;_&nbsp;`string`

_model_&nbsp;`string` _rate_&nbsp;`integer` _&rarr;_&nbsp;`string`

Update or query current gas model. With just MODEL, "table" is supported; with
MODEL and RATE, 'fixed' is supported. With no args, output current model.

```lisp
pact> (env-gasmodel)
"Current gas model is 'fixed 0': constant rate gas model with fixed rate 0"
pact> (env-gasmodel 'table)
"Set gas model to table-based cost model"
pact> (env-gasmodel 'fixed 1)
"Set gas model to constant rate gas model with fixed rate 1"
```

### env-gasprice

_price_&nbsp;`decimal` _&rarr;_&nbsp;`string`

Set environment gas price to PRICE.

### env-gasrate

_rate_&nbsp;`integer` _&rarr;_&nbsp;`string`

Update gas model to charge constant RATE.

### env-hash

_hash_&nbsp;`string` _&rarr;_&nbsp;`string`

Set current transaction hash. HASH must be an unpadded base64-url encoded
BLAKE2b 256-bit hash.

```lisp
pact> (env-hash (hash "hello"))
"Set tx hash to Mk3PAn3UowqTLEQfNlol6GsXPe-kuOWJSCU0cbgbcs8"
```

### env-keys

_keys_&nbsp;`[string]` _&rarr;_&nbsp;`string`

DEPRECATED in favor of 'env-sigs'. Set transaction signer KEYS. See 'env-sigs'
for setting keys with associated capabilities.

```lisp
pact> (env-keys ["my-key" "admin-key"])
"Setting transaction keys"
```

### env-namespace-policy

_allow-root_&nbsp;`bool` _ns-policy-fun_&nbsp;`ns:string ns-admin:guard -> bool`
_&rarr;_&nbsp;`string`

Install a managed namespace policy specifying ALLOW-ROOT and NS-POLICY-FUN.

```lisp
(env-namespace-policy (my-ns-policy-fun))
```

### env-sigs

_sigs_&nbsp;`[object:*]` _&rarr;_&nbsp;`string`

Set transaction signature keys and capabilities. SIGS is a list of objects with
"key" specifying the signer key, and "caps" specifying a list of associated
capabilities.

```lisp
(env-sigs [{'key: "my-key", 'caps: [(accounts.USER_GUARD "my-account")]}, {'key: "admin-key", 'caps: []}
```

### env-simulate-onchain

_on-chain_&nbsp;`bool` _&rarr;_&nbsp;`string`

Set a flag to simulate on-chain behavior that differs from the repl, in
particular for observing things like errors and stack traces.

```lisp
(env-simulate-onchain true)
```

### expect

_doc_&nbsp;`string` _expected_&nbsp;`<a>` _actual_&nbsp;`<a>`
_&rarr;_&nbsp;`string`

Evaluate ACTUAL and verify that it equals EXPECTED.

```lisp
pact> (expect "Sanity prevails." 4 (+ 2 2))
"Expect: success: Sanity prevails."
```

### expect-failure

_doc_&nbsp;`string` _exp_&nbsp;`<a>` _&rarr;_&nbsp;`string`

_doc_&nbsp;`string` _err_&nbsp;`string` _exp_&nbsp;`<a>` _&rarr;_&nbsp;`string`

Evaluate EXP and succeed only if it throws an error.

```lisp
pact> (expect-failure "Enforce fails on false" (enforce false "Expected error"))
"Expect failure: success: Enforce fails on false"
pact> (expect-failure "Enforce fails with message" "Expected error" (enforce false "Expected error"))
"Expect failure: success: Enforce fails with message"
```

### expect-that

_doc_&nbsp;`string` _pred_&nbsp;`value:<a> -> bool` _exp_&nbsp;`<a>`
_&rarr;_&nbsp;`string`

Evaluate EXP and succeed if value passes predicate PRED.

```lisp
pact> (expect-that "addition" (< 2) (+ 1 2))
"Expect-that: success: addition"
pact> (expect-that "addition" (> 2) (+ 1 2))
"FAILURE: addition: did not satisfy (> 2) : 3:integer"
```

### format-address

_scheme_&nbsp;`string` _public-key_&nbsp;`string` _&rarr;_&nbsp;`string`

Transform PUBLIC-KEY into an address (i.e. a Pact Runtime Public Key) depending
on its SCHEME.

### load

_file_&nbsp;`string` _&rarr;_&nbsp;`string`

_file_&nbsp;`string` _reset_&nbsp;`bool` _&rarr;_&nbsp;`string`

Load and evaluate FILE, resetting repl state beforehand if optional RESET is
true.

```lisp
(load "accounts.repl")
```

### mock-spv

_type_&nbsp;`string` _payload_&nbsp;`object:*` _output_&nbsp;`object:*`
_&rarr;_&nbsp;`string`

Mock a successful call to 'spv-verify' with TYPE and PAYLOAD to return OUTPUT.

```lisp
(mock-spv "TXOUT" { 'proof: "a54f54de54c54d89e7f" } { 'amount: 10.0, 'account: "Dave", 'chainId: "1" })
```

### pact-state

_&rarr;_&nbsp;`object:*`

_clear_&nbsp;`bool` _&rarr;_&nbsp;`object:*`

Inspect state from most recent pact execution. Returns object with fields
'pactId': pact ID; 'yield': yield result or 'false' if none; 'step': executed
step; 'executed': indicates if step was skipped because entity did not match.
With CLEAR argument, erases pact from repl state.

```lisp
(pact-state)
(pact-state true)
```

### print

_value_&nbsp;`<a>` _&rarr;_&nbsp;`string`

Output VALUE to terminal as unquoted, unescaped text.

### rollback-tx

_&rarr;_&nbsp;`string`

Rollback transaction.

```lisp
pact> (begin-tx "Third Act") (rollback-tx)
"Rollback Tx 0: Third Act"
```

### sig-keyset

_&rarr;_&nbsp;`keyset`

Convenience function to build a keyset from keys present in message signatures,
using 'keys-all' as the predicate.

### test-capability

_capability_&nbsp;` -> bool` _&rarr;_&nbsp;`string`

Acquire (if unmanaged) or install (if managed) CAPABILITY. CAPABILITY and any
composed capabilities are in scope for the rest of the transaction.

```lisp
(test-capability (MY-CAP))
```

### typecheck

_module_&nbsp;`string` _&rarr;_&nbsp;`string`

_module_&nbsp;`string` _debug_&nbsp;`bool` _&rarr;_&nbsp;`string`

Typecheck MODULE, optionally enabling DEBUG output.

### verify

_module_&nbsp;`string` _debug_&nbsp;`bool` _&rarr;_&nbsp;`string`

Verify MODULE, checking that all properties hold. Optionally, if DEBUG is set to
true, write debug output to "pact-verify-MODULE" directory.

```lisp
(verify "module")
(verify "module" true)
```

### with-applied-env

_exec_&nbsp;`<a>` _&rarr;_&nbsp;`<a>`

Evaluate EXEC with any pending environment changes applied. Normally,
environment changes must execute at top-level for the change to take effect.
This allows scoped application of non-toplevel environment changes.

```lisp
pact> (let ((a 1)) (env-data { 'b: 1 }) (with-applied-env (+ a (read-integer 'b))))
2
```
