---
title: Kadena Chainweb Node API
menu: Chainweb
label: Kadena Chainweb Node API
order: 1
layout: full
---

## P2P API (p2p_api)

    ```The P2P API is used for inter-node communication in order to establish block

chain consensus. Each chainweb-node serves these endpoints via HTTPS on a
network interface and port that is available directly on the public internet.

Additionally, endpoints of the P2P API can be made available for other clients.
For this purpose it is possible to expose the endpoints via reverse proxies,
load balancers, or authentication frameworks, and similar web technologies.

````




     ## Service API (service_api)


    ```The Service API includes endpoints that expose functionality of
chainweb-node to clients other than chainweb-nodes, such as mining pools,
DAPPs, web applications, exchanges, wallets, etc.

The endpoints of the service API are optional and can be enabled via
respective configuration settings. They are served on a separate port via
plain HTTP. Node operators are free to expose those endpoints only locally,
or via reverse proxies, load balancers, authentication frameworks, and
similar web technologies.

Some of the endpoints of the service API can require considerable resources
on the server side and administrators should be careful when exposing those
publicly. Generally, endpoints of the service API are more vulnerable to DOS
attacks.
````

     ## Cut Endpoints (cut)


    ```A cut represents a distributed state of a chainweb. It references one

block header for each chain, such that those blocks are pairwise concurrent.

Two blocks from two different chains are said to be concurrent if either one of
them is an adjacent parent (is a direct dependency) of the other or if the
blocks do not depend at all on each other.

````




    ```
    s v/cut v[object Object]
    ```


     ## Peer Endpoints (peer)


    ```The P2P communication between chainweb-nodes is sharded into several independent
P2P network. The `cut` network is exchanging consensus state. There is also one
mempool P2P network for each chain.
````

    ```
    s v/cut/peer v[object Object]
    ```


     ## Mempool P2P Endpoints (mempool)


    ```Mempool P2P endpoints for communication between mempools. Endusers are not

supposed to use these endpoints directly. Instead, the respective Pact endpoints
should be used for submitting transactions into the network.

````




    ```
    s v/chain/{chain}/mempool/getPending v[object Object]
    ```


     ## Block Payload Endpoints (payload)


    ```Raw literal Block Payloads in the form in which they are stored on the chain.
By default only the payload data is returned which is sufficient for validating
the blockchain Merkle Tree. It is also sufficient as input to Pact for
executing the Pact transactions of the block and recomputing the outputs.

It is also possible to query the transaction outputs along with the payload data.
````

    ```
    s v/chain/{chain}/payload/{payloadHash} v[object Object]
    ```


     ## Block Hashes Endpoints (blockhash)


    ```These endpoints return block hashes from the chain database.

Generally, block hashes are returned in ascending order and include hashes from
orphaned blocks.

For only querying blocks that are included in the winning branch of the chain
the `branch` endpoint can be used, which returns blocks in descending order
starting from the leafs of branches of the block chain.

````




    ```
    s v/chain/{chain}/hash v[object Object]
    ```


     ## Block Header Endpoints (header)


    ```These endpoints return block headers from the chain database.

Generally, block headers are returned in ascending order and include headers
of orphaned blocks.

For only querying blocks that are included in the winning branch of the
chain the `branch` endpoints can be used, which return blocks in descending
order starting from the leafs of branches of the block chain.

Block headers are returned in three different formats specified in the `accept` header of the request:
*   `application/json`, returns block headers in base64Url (without padding)
    encoded binary.
*   `application/json;blockheader-encoding=object`, returns block headers in
    JSON encoding.
*   `application/octet-stream`, when supported by the endpoint, returns block
    headers as binary.
````

    ```
    s v/chain/{chain}/header v[object Object]
    ```


     ## Config Endpoint (config)


    ```undefined```




    ```
    s v/config v[object Object]
    ```


     ## Miscellaneous Endpoints (misc)


    ```undefined```




    ```
    s v/config v[object Object]
    ```


     ## Pact Endpoints (pact)


    ```The [Pact](https://pactlang.org) endpoints are documented in the [Pact API

Specification](./pact.html).

The Pact endpoints for chain `{chainId}` use the route prefix
`/chain/{chainId}/pact/` in addition to the base URL.

Futher details can also be found in
[this section of the Pact Language Reference](https://pact-language.readthedocs.io/en/stable/pact-reference.html#endpoints).

````




     ## Rosetta Endpoints (rosetta)


    ```Chainweb node includes an implementation of the
[Rosetta API](https://www.rosetta-api.org). The API is disabled by default
and can be enabled in the configuration file of a node.

The following endpoints are supported, which are documented
in the [Rosetta Specification](https://www.rosetta-api.org/docs/welcome.html):

*   `POST rosetta/account/balance`
*   `POST rosetta/block/transaction`
*   `POST rosetta/block`
*   `POST rosetta/construction/metadata`
*   `POST rosetta/construction/submit`
*   `POST rosetta/mempool/transaction`
*   `POST rosetta/mempool`
*   `POST rosetta/network/list`
*   `POST rosetta/network/options`
*   `POST rosetta/network/status`
````

     ## Mining Endpoints (mining)


    ```The Mining API of Chainweb node is disabled by default. It can be enabled

and configured in the configuration file.

The mining API consists of the following endpoints that are described in detail
on the
[Chainweb mining wiki page](https://github.com/kadena-io/chainweb-node/wiki/Mining-API)

- `GET mining/work`
- `POST mining/solved`
- `GET mining/updates`

````




    ```
    s v/mining/work v[object Object]
    ```


     ## Block Header Binary Encoding (binaryHeader)


    ```## Binary Format For Chain Graphs of Degree Three

defined in `Chainweb.BlockHeader`

| Size | Bytes   | Value       |
| ---- | ------- | ----------- |
| 8    | 0-7     | flags       |
| 8    | 8-15    | time        |
| 32   | 16-47   | parent      |
| 110  | 48-157  | adjacents   |
| 32   | 158-189 | target      |
| 32   | 190-221 | payload     |
| 4    | 222-225 | chain       |
| 32   | 226-257 | weight      |
| 8    | 258-265 | height      |
| 4    | 266-269 | version     |
| 8    | 270-277 | epoch start |
| 8    | 278-285 | nonce       |
| 32   | 286-317 | hash        |

total: 318 bytes

Adjacent Parents Record (length 3):

| Bytes | Value     |
| ----- | --------- |
| 0-1   | length    |
| 2-109 | adjacents |

total: 110 bytes

Adjacent Parent:

| Bytes | Value |
| ----- | ----- |
| 0-3   | chain |
| 4-35  | hash  |

total: 36 bytes

## Fields

**POW related values**:

Arithmetic operations and comparisons on `parent`, `target`, `weight`, and `hash`
interpret the value as unsigned 256 bit integral numbers in little endian encoding.
All operations are performed using rational arithmetic of unlimited precision and the final result is rounded.
Please consult the code for details of how the result is rounded.

**Time Stamps**:

`time` and `epoch start` are a little endian twoth complement encoded integral numbers that count SI microseconds since POSIX epoch (leap seconds are ignored). These numbers are always positive (highest bit is 0).

**Numbers**:

* `height` is a little endian encoded unsigned integral 64 bit number.
* `length` is a little endian encoded unsigned integral 16 bit number.

**Version**:

`version` identifies the chainweb version. It is a 32 bit value in little endian encoding.
Values up to 0x0000FFFF are reserved for production versions (which includes `development` and testnets).

| value      | version     |
| ---------- | ----------- |
| 0x00000005 | mainnet01   |
| 0x00000001 | development |
| 0x00000007 | testnet04   |

**Other**:

* `nonce` is any sequence of 8 bytes that is only compared for equality.
* `chain` is any sequence of 4 bytes that identifies a chain and can be compared for equality.
* `payload` is any sequence of 32 bytes that is a cryptographic hash of the payload associated with the block and can be compared for equality.
* `flags` are eight bytes of value 0x0 that are reserved for future use.
````

     ## Work Header Binary Encoding (binaryWorkHeader)


    ```The work bytes received from the `/miner/work` endpoint is slightly different than the above header format. These headers do not include the block hash, instead prefixing the header above (without hash) with chain id and hash target bytes.

The first 36 bytes are informational. Only the bytes from position 36 to the end
are subject of the POW hash computation.

The final 8 bytes are the nonce. The creation time is encoded in bytes 44-52
(see above for details of the encoding). Miners are allowed, but not required,
to update the time to reflect the solve time for the block more closely. A
larger value for the creation time increases the accuracy of difficulty
adjustment which is in the interest of miners -- the high difficulty guarantees
that the outcome of the race of winning blocks is determined by actual hash
power. However, blocks that are predated (i.e. have a creation time that is in
the future) are rejected during block header validation. Leaving the time
unchanged is a valid choice.

Miners must not change or make any assumptions about the content of the
"reserved" bytes.

Defined in `Chainweb.Miner.Core`

| Size | Bytes   | Work Bytes | Value       |
| ---- | ------- | ---------- | ----------- |
| 4    | 0-3     | NA         | chain       |
| 32   | 4-35    | NA         | hash-target |
|      |         |            |             |
| 8    | 36-43   | 0-7        | reserved    |
| 8    | 44-51   | 8-15       | **time**    |
| 298  | 52-313  | 16-277     | reserved    |
| 8    | 314-321 | 278-285    | **nonce**   |

total: 322 bytes

For arithmetic comparisons the `hash-target` is interpreted as unsigned 256 bit
integral number in little endian encoding.

`time` is a little endian twoth complement encoded integral number that counts
SI microseconds since POSIX epoch (leap seconds are ignored). The value is
always positive (highest bit is 0).

````




     ## Cut Model (cut_model)


    ```The `origin` property is required for use with the `PUT /cut` endpoint.
<SchemaDefinition schemaRef="#/components/schemas/cut" showReadOnly={true} showWriteOnly={true} />
````

     ## Payload Model (payload_model)


    ```<SchemaDefinition schemaRef="#/components/schemas/payload" showReadOnly={true} showWriteOnly={true} />

````




     ## Payload With Outputs Model (payloadWithOutputs_model)


    ```<SchemaDefinition schemaRef="#/components/schemas/payloadWithOutputs" showReadOnly={true} showWriteOnly={true} />
````

     ## Block Header Model (header_model)


    ```<SchemaDefinition schemaRef="#/components/schemas/blockHeader" showReadOnly={true} showWriteOnly={true} />

````




     ## Peer Info Model (peer_model)


    ```<SchemaDefinition schemaRef="#/components/schemas/peer" showReadOnly={true} showWriteOnly={true} />

## Compute PeerInfo

Generally, it is easier to query the peer info of a peer using a GET query for a peer database.
Otherwise the peer info can be computed as follows.

For peers that use domain names with valid CA signed SSL certificates the peer id is `null`.

For peers with self-signed certificates the peer id is the base64Url (without padding) encoded
SHA256 fingerprint of the certificate. For a chainweb-node `NODE` it can be computed as follows:

```sh
echo |
openssl s_client -showcerts -servername ${NODE} -connect ${NODE}:443 2>/dev/null |
openssl x509 -fingerprint -noout -sha256 |
sed 's/://g' |
tail -c 65 |
xxd -r -p |
base64 |
tr -d '=' |
tr '/+' '_-'
````

````




     ## Chainweb Node Info Model (nodeInfo_model)


    ```<SchemaDefinition schemaRef="#/components/schemas/nodeInfo" showReadOnly={true} showWriteOnly={true} />
````

     ## Collection Page Model (page_model)


    ```<SchemaDefinition schemaRef="#/components/schemas/page" showReadOnly={true} showWriteOnly={true} />

````




     ## Miner Info Model (minerInfo_model)


    ```<SchemaDefinition schemaRef="#/components/schemas/minerInfo" showReadOnly={true} showWriteOnly={true} />
````

     ## Mining Update Event Stream Model (miningUpdateEventStream_model)


    ```A server-sent event sources that notifies miners when new mining work

becomes available. The stream is terminated by the server in regular intervals
and it is up to the client to request a new stream.

Each event consists of a single line: `event:New Cut`. Events are separated by
empty lines.

<SchemaDefinition
  schemaRef="#/components/schemas/miningUpdateEventStream"
  showReadOnly={true}
  showWriteOnly={true}
/>
```

     ## Response Headers (commonResponseHeaders)


    ```

## Server Timestamp

`x-server-timestamp`: The time of the clock of the remote node

<SchemaDefinition
  schemaRef="#/components/schemas/posixTimestamp"
  showReadOnly={true}
  showWriteOnly={true}
/>

## Chainweb Node Version

`x-chainweb-node-version`: The version of the remote chainweb node

<SchemaDefinition
  schemaRef="#/components/schemas/chainwebVersion"
  showReadOnly={true}
  showWriteOnly={true}
/>

## Client Peer Address

`x-peer-addr`: Host and port of the client as observed by the remote node

<SchemaDefinition
  schemaRef="#/components/schemas/hostAddress"
  showReadOnly={true}
  showWriteOnly={true}
/>
```
