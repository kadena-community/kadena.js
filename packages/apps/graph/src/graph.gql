# wallet
# - balances
# - history transactions
# fungibles
# - holders (exclude dust)
# - transfers filtered by pubkey
# - transfers filtered by token
# explorer (insight + incentive(!))
# - requestkey polling
# - crosschain transactions + continuations
# dapp
# - events
# - remove code (now misused)
# non-fungibles
# domain shortname kda wallet service (https://www.aptosnames.com/)

# - lijstje met basics voor ecosystem te thriven

# account: a holder of fungibles
type Query {
  lastBlockHeight: Int!
  getAccount(accountName: String!, filter: GetAccountFilter): Account!
  node(id: ID!): Node!
  nodes(ids: [ID!]!): [Node!]!
}

extend type Query {
  hello: String
}

# query {
#   getAccount(accountName: "alber70g") {
#     id
#     accountName
#     totalBalance
#     transactions {

#     }
#   }
# }

input GetAccountFilter {
  module: String
}

interface Node {
  id: ID!
}

type Account {
  """
  The id of the account, being __typename:accountName
  e.g.: Account:k:oairestnoiarsetn
  """
  id: ID!
  accountName: String!
  chains: [ChainAccount!]!
  totalBalance: Float!
  transactions: [Transaction!]!
}

# query TheTransactions {
#   getAccount(filter: {accountName: "alber70g"}) {
#     transactions {
#       ... on TransferTransaction {
#         from {
#           id
#           accountName
#         }
#       }
#     }
#   }
# }

type ChainAccount {
  chainId: ID!
  guard: Guard!
  balance: Float!
  module: String!
  """
  All transactions where the sender is this account
  """
  transactions: [Transaction!]!
  """
  All transfers where the sender or receiver is this account
  """
  transfers(module: String): [Transfer!]!
}

type Transaction {
  cmd: String!
  hash: String!
  signatures: [String!]!
}

"""
Transfer is a fungible transfer, with one or more transactions.
When there are more than one transaction, it means that the transfer was a crosschain transfer.
Any transaction that emits "TRANSFER" "TRANSFER_XCHAIN_RECD"
"""
type Transfer {
  from: Account!
  to: Account!
  amount: Float!
  transaction: [Transaction]!
}

type Guard {
  keys: [String!]!
  predicate: KeysetPredicate!
}

enum KeysetPredicate {
  KeysAll
  KeysAny
  KeysTwo
}

# base64(type, repo, branch/commit, path)("file", "alber70g/eenrepo", "master", "package.json") = 02938l9287459128934
# url: iets.com/repo/branch/path
# query file {
#   node(id: "02938l9287459128934") {
#     ... on File {
#       name
#       contents
#     }
#   }
# }

type Subscription {
  newBlocks: [Block!]!
  #   events(eventName: [String]): [Event!]!
  #   poll(requestKey: String!): PollResponse
}

# query EventsForMe {
#   events(eventName: ["kdlaunch.kdswap-exchange.UPDATE"]) {}
# }

# type Mutation {
#   send(sendBody: SendBody): SendResponse
#   local(localBody: LocalBody): LocalResponse

#   # crosschain transfers, insight in hops + estimate time to confirmation
#   transfer(from: String, to: String): Transfer!
# }

# Another question that came up recently was abstracting chains the chainweb-node API level, to make coding clients more convenient.
# [11:25 PM] At the moment that has a relatively low priority.
# [11:28 PM] One reason is that the following tasks have higher priority (highest to lowest):
# improving performance of payload queries (in particular ranges of payloads)
# providing more convenient APIs for block height based queries of items (on per chain basis). The goal is that all applicable service API queries should provide a confirmation depth and/or block height parameter.
# adding better SSE APIs directly in chainweb node that would allow to to project and filter queried data server side.
# [11:31 PM] Another reason is that in order to retain the ability to scale to larger numbers of chains, the backend has to be sharded by chains. Therefore chain agnostic APIs would be a middleware layer above the per chain APIs. While it makes sense to offer such a layer at some point as part of chainweb-node, the implementation would depend on some fundamental architectural design choices about how to implement horizontal scaleability in chainweb-node.
# [11:33 PM] For the moment, we think, a chain-agnostic APIs should be better implemented as proxy servers or dedicate middleware independent of chainweb-node.
# [11:35 PM] That said, I love to here any feed back about chainweb-node APIs. We are currently moving a bit slow in making changes in this field, but I hope that we can spent more time on it in the coming year (realistically more towards Q2 or Q3).

################

# Block is a block from the Chainweb blockchain
type Block {
  id: Int!
  chainid: BigInt!
  creationtime: Date!
  epoch: Date!
  flags: Float!
  hash: ID!
  height: BigInt!
  miner: String!
  nonce: Float!
  parent: String!
  payload: String!
  powhash: String!
  predicate: String!
  target: PositiveFloat!
  weight: PositiveFloat!
}
