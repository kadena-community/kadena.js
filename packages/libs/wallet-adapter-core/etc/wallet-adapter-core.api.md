## API Report File for "@kadena/wallet-adapter-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ChainId } from '@kadena/client';
import { ICommand } from '@kadena/client';
import type { IExecutionPayloadObject } from '@kadena/client';
import { IKeyPair } from '@kadena/client';
import type { IPactCommand } from '@kadena/client';
import type { IQuicksignResponse } from '@kadena/client';
import type { ISigningRequest } from '@kadena/client';
import { IUnsignedCommand } from '@kadena/client';
import { StandardSchemaV1 } from '@standard-schema/spec';

// @public
export interface AccountInfo {
    // (undocumented)
    accountName: string;
    // (undocumented)
    chainAccounts: string[];
    // (undocumented)
    contract: string;
    // (undocumented)
    guard: {
        keys: string[];
        pred: string;
    };
    // (undocumented)
    networkId: string;
}

// @public
export interface Adapter {
    // (undocumented)
    changeNetwork(network: NetworkInfo): Promise<{
        success: boolean;
        reason?: string;
    }>;
    // (undocumented)
    connect(params?: unknown): Promise<AccountInfo | null>;
    // (undocumented)
    disconnect(): Promise<void>;
    // (undocumented)
    getAccounts(): Promise<AccountInfo[]>;
    // (undocumented)
    getActiveAccount(): Promise<AccountInfo>;
    // (undocumented)
    getActiveNetwork(): Promise<NetworkInfo>;
    // (undocumented)
    getNetworks(): Promise<NetworkInfo[]>;
    // (undocumented)
    name: string;
    // (undocumented)
    off(event: string, listener: (...args: any[]) => void): this;
    // (undocumented)
    on(event: string, listener: (...args: any[]) => void): this;
    // (undocumented)
    onAccountChange(cb: (newAccount: AccountInfo) => void): void;
    // (undocumented)
    onNetworkChange(cb: (newNetwork: NetworkInfo) => void): void;
    // (undocumented)
    request(args: {
        method: string;
        [key: string]: any;
    }): Promise<unknown>;
    // (undocumented)
    signCommand(command: ISigningRequestPartial | IUnsignedCommand): Promise<ICommand | IUnsignedCommand>;
    // (undocumented)
    signTransaction(transaction: IUnsignedCommand | IUnsignedCommand[]): Promise<(IUnsignedCommand | ICommand) | (IUnsignedCommand | ICommand)[]>;
}

// @public (undocumented)
export type AdapterFactory = ReturnType<AdapterFactoryCreator>;

// @public (undocumented)
export type AdapterFactoryCreator = <T extends BaseWalletFactoryOptions>(options: T) => {
    name: string;
    detect(): Promise<Provider | null>;
    adapter(provider: Provider): Promise<Adapter>;
};

// @public (undocumented)
export interface AdapterFactoryData {
    // (undocumented)
    detected: boolean;
    // (undocumented)
    name: string;
}

// @public
export abstract class BaseWalletAdapter implements Adapter {
    constructor(options: BaseWalletAdapterOptions);
    changeNetwork(network: NetworkInfo): Promise<{
        success: boolean;
        reason?: string;
    }>;
    connect(params: StandardSchemaV1.InferInput<NonNullable<typeof BaseWalletAdapter.connectSchema>>): Promise<AccountInfo | null>;
    // (undocumented)
    connectSchema: StandardSchemaV1;
    disconnect(): Promise<void>;
    getAccounts(): Promise<AccountInfo[]>;
    getActiveAccount(): Promise<AccountInfo>;
    getActiveNetwork(): Promise<NetworkInfo>;
    getNetworks(): Promise<NetworkInfo[]>;
    // (undocumented)
    abstract name: string;
    // (undocumented)
    protected networkId: string;
    // (undocumented)
    off(event: string, listener: (...args: any[]) => void): this;
    // (undocumented)
    on(event: string, listener: (...args: any[]) => void): this;
    onAccountChange(cb: (newAccount: AccountInfo) => void): void;
    onNetworkChange(cb: (newNetwork: NetworkInfo) => void): void;
    // (undocumented)
    protected provider: Provider;
    request<M extends KdaMethod>(args: KdaRequestArgs<M>): Promise<KdaMethodMap[M]['response']>;
    signCommand(command: IUnsignedCommand | ISigningRequestPartial): Promise<ICommand | IUnsignedCommand>;
    signTransaction(command: IUnsignedCommand | IUnsignedCommand[]): Promise<(IUnsignedCommand | ICommand) | (IUnsignedCommand | ICommand)[]>;
}

// @public (undocumented)
export interface BaseWalletAdapterOptions {
    // (undocumented)
    networkId?: string;
    // (undocumented)
    provider: Provider;
}

// @public (undocumented)
export interface BaseWalletFactoryOptions {
    // (undocumented)
    networkId?: string;
}

export { ChainId }

// @public (undocumented)
export type CommandSigDatas = {
    cmd: string;
    sigs: {
        pubKey: string;
        sig: string | null;
    }[];
}[];

// @public
export const convertSignRequest: (parsedTransaction: IPactCommand) => ISigningRequestPartial;

// @public
export const finalizeQuickSignTransaction: (response: IQuicksignResponse, transactionHashes: string[], transactions: (IUnsignedCommand | ICommand)[], isList: boolean) => IUnsignedCommand | (IUnsignedCommand | ICommand)[];

export { ICommand }

export { IKeyPair }

// @public
export function isExecCommand(parsedTransaction: IPactCommand): parsedTransaction is IPactCommand & {
    payload: IExecutionPayloadObject;
};

// @public (undocumented)
export type ISigningRequestPartial = {
    caps: ISigningRequest['caps'];
    code: string;
} & Omit<Partial<ISigningRequest>, 'caps' | 'pactCode'>;

// @public (undocumented)
export const isJsonRpcResponse: (response: any) => boolean;

// @public (undocumented)
export const isJsonRpcSuccess: <T>(response: JsonRpcResponse<T>) => response is JsonRpcSuccess<T>;

export { IUnsignedCommand }

// @public (undocumented)
export interface JsonRpcError {
    // (undocumented)
    error: {
        code: number;
        message: string;
        data?: object;
    };
    // (undocumented)
    id: number;
    // (undocumented)
    jsonrpc: '2.0';
}

// @public (undocumented)
export type JsonRpcResponse<T> = JsonRpcSuccess<T> | JsonRpcError;

// @public (undocumented)
export interface JsonRpcSuccess<T> {
    // (undocumented)
    id: number;
    // (undocumented)
    jsonrpc: '2.0';
    // (undocumented)
    result: T;
}

// @public (undocumented)
export type KdaConnectOptions = Record<string, any>;

// @public (undocumented)
export type KdaMethod = keyof KdaMethodMap;

// @public (undocumented)
export interface KdaMethodMap {
    // (undocumented)
    kadena_changeNetwork_v1: {
        params: {
            networkId: string;
        };
        response: JsonRpcResponse<{
            success: boolean;
            reason?: string;
        }>;
    };
    // (undocumented)
    kadena_connect: {
        params: KdaConnectOptions;
        response: JsonRpcResponse<any>;
    };
    // (undocumented)
    kadena_disconnect: {
        params: {
            networkId?: string;
        };
        response: JsonRpcResponse<void>;
    };
    // (undocumented)
    kadena_getAccount_v1: {
        params: {};
        response: JsonRpcResponse<AccountInfo>;
    };
    // (undocumented)
    kadena_getAccounts_v2: {
        params: {};
        response: JsonRpcResponse<AccountInfo[]>;
    };
    // (undocumented)
    kadena_getNetwork_v1: {
        params: {};
        response: JsonRpcResponse<NetworkInfo>;
    };
    // (undocumented)
    kadena_getNetworks_v1: {
        params: {};
        response: JsonRpcResponse<NetworkInfo[]>;
    };
    // (undocumented)
    kadena_quicksign_v1: {
        params: {
            commandSigDatas: CommandSigDatas;
        };
        response: JsonRpcResponse<IQuicksignResponse>;
    };
    // (undocumented)
    kadena_sign_v1: {
        params: ISigningRequestPartial;
        response: JsonRpcResponse<{
            body: ICommand | IUnsignedCommand;
            chainId: ChainId;
        }>;
    };
}

// @public (undocumented)
export type KdaRequestArgs<M extends KdaMethod> = {
    method: M;
} & {
    params?: KdaMethodMap[M]['params'];
};

// @public
export interface NetworkInfo {
    // (undocumented)
    networkId: string;
    // (undocumented)
    networkName: string;
    // (undocumented)
    url?: string[];
}

// @public
export type OptionalKeyPair = Omit<IKeyPair, 'secretKey'> & {
    secretKey?: string;
};

// @public
export const parseTransactionCommand: (transaction: IUnsignedCommand | ICommand) => IPactCommand;

// @public
export const prepareQuickSignCmd: (transactionList: IUnsignedCommand | Array<IUnsignedCommand | ICommand>) => Promise<{
    commandSigDatas: {
        cmd: string;
        sigs: {
            pubKey: string;
            sig: string | null;
        }[];
    }[];
    transactionHashes: string[];
    transactions: (IUnsignedCommand | ICommand)[];
    isList: boolean;
}>;

// @public
export function prepareSignCmd(transaction: IUnsignedCommand | ICommand | ISigningRequestPartial): ISigningRequestPartial;

// @public (undocumented)
export interface Provider {
    // (undocumented)
    off(event: string, listener: (...args: any[]) => void): void;
    // (undocumented)
    on(event: string, listener: (...args: any[]) => void): void;
    // (undocumented)
    request(args: {
        method: string;
        [key: string]: any;
    }): Promise<unknown>;
}

export { StandardSchemaV1 }

// @public
export class WalletAdapterClient {
    constructor(adapters: (Adapter | AdapterFactory)[]);
    changeNetwork(adapterName: string, network: NetworkInfo): Promise<{
        success: boolean;
        reason?: string;
    }>;
    connect(adapterName: Adapter['name'], params?: unknown): Promise<AccountInfo | null>;
    disconnect(adapterName: string): Promise<void>;
    getAccounts(adapterName: string): Promise<AccountInfo[]>;
    getActiveAccount(adapterName: string): Promise<AccountInfo>;
    getActiveNetwork(adapterName: string): Promise<NetworkInfo>;
    // (undocumented)
    getAdapter(adapterName: string): Adapter | undefined;
    // (undocumented)
    getDetectedAdapters(): Adapter[];
    getNetworks(adapterName: string): Promise<NetworkInfo[]>;
    // (undocumented)
    getProviders(): {
        name: string;
        detected: boolean;
    }[];
    // (undocumented)
    init(): Promise<void>;
    // (undocumented)
    isDetected(name: string): boolean;
    onAccountChange(adapterName: string, cb: (newAccount: AccountInfo) => void): void;
    // (undocumented)
    onAdapterDetected(cb: (adapter: Adapter) => void, options?: {
        signal?: AbortSignal;
    }): void;
    onNetworkChange(adapterName: string, cb: (newNetwork: NetworkInfo) => void): void;
    request(adapterName: string, args: {
        method: string;
        [key: string]: any;
    }): Promise<unknown>;
    signCommand(adapterName: string, command: ISigningRequestPartial | IUnsignedCommand): Promise<ICommand | IUnsignedCommand>;
    signTransaction(adapterName: string, transaction: IUnsignedCommand | IUnsignedCommand[]): Promise<(IUnsignedCommand | ICommand) | (IUnsignedCommand | ICommand)[]>;
}

// (No @packageDocumentation comment for this package)

```
