## API Report File for "@kadena/wallet-adapter-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ChainId } from '@kadena/client';
import { ICommand } from '@kadena/client';
import type { IExecutionPayloadObject } from '@kadena/client';
import { IKeyPair } from '@kadena/client';
import type { IPactCommand } from '@kadena/client';
import type { IQuicksignResponse } from '@kadena/client';
import type { ISigningRequest } from '@kadena/client';
import { IUnsignedCommand } from '@kadena/client';
import { StandardSchemaV1 } from '@standard-schema/spec';

// @public (undocumented)
export type AdapterFactory = ReturnType<AdapterFactoryCreator>;

// @public (undocumented)
export type AdapterFactoryCreator = <T extends IBaseWalletFactoryOptions>(options: T) => {
    name: string;
    detect(): Promise<IProvider | null>;
    adapter(provider: IProvider): Promise<IAdapter>;
};

// @public
export abstract class BaseWalletAdapter implements IAdapter {
    constructor(options: IBaseWalletAdapterOptions);
    connect(params: StandardSchemaV1.InferInput<NonNullable<typeof BaseWalletAdapter.connectSchema>>): Promise<IAccountInfo | null>;
    // (undocumented)
    connectSchema: StandardSchemaV1;
    disconnect(): Promise<void>;
    getAccounts(): Promise<IAccountInfo[]>;
    getActiveAccount(): Promise<IAccountInfo>;
    getActiveNetwork(): Promise<INetworkInfo>;
    getNetworks(): Promise<INetworkInfo[]>;
    // (undocumented)
    abstract name: string;
    // (undocumented)
    protected networkId: string;
    // (undocumented)
    off(event: string, listener: (...args: any[]) => void): this;
    // (undocumented)
    on(event: string, listener: (...args: any[]) => void): this;
    onAccountChange(cb: (newAccount: IAccountInfo) => void): void;
    onNetworkChange(cb: (newNetwork: INetworkInfo) => void): void;
    // (undocumented)
    protected provider: IProvider;
    request<M extends KdaMethod>(args: KdaRequestArgs<M>): Promise<IKdaMethodMap[M]['response']>;
    signCommand(command: IUnsignedCommand | ISigningRequestPartial): Promise<ICommand | IUnsignedCommand>;
    signTransaction(command: IUnsignedCommand | IUnsignedCommand[]): Promise<(IUnsignedCommand | ICommand) | (IUnsignedCommand | ICommand)[]>;
}

// @public (undocumented)
export type CapabilityGuard = {
    cgName: string;
    cgArgs: PactValue[];
    cgPactId?: string;
};

export { ChainId }

// @public (undocumented)
export type CommandSigDatas = {
    cmd: string;
    sigs: {
        pubKey: string;
        sig: string | null;
    }[];
}[];

// @public
export const convertSignRequest: (parsedTransaction: IPactCommand) => ISigningRequestPartial;

// @public
export const finalizeQuickSignTransaction: (response: IQuicksignResponse, transactionHashes: string[], transactions: (IUnsignedCommand | ICommand)[], isList: boolean) => IUnsignedCommand | (IUnsignedCommand | ICommand)[];

// @public (undocumented)
export type Guard = KeySet | KeySetRef | UserGuard | CapabilityGuard | ModuleGuard | PactGuard;

// @public
export interface IAccountInfo {
    // (undocumented)
    accountName: string;
    // (undocumented)
    chainAccounts: string[];
    // (undocumented)
    contract: string;
    // (undocumented)
    guard: Guard;
    // (undocumented)
    networkId: string;
}

// @public
export interface IAdapter {
    // (undocumented)
    connect(params?: unknown): Promise<IAccountInfo | null>;
    // (undocumented)
    disconnect(): Promise<void>;
    // (undocumented)
    getAccounts(): Promise<IAccountInfo[]>;
    // (undocumented)
    getActiveAccount(): Promise<IAccountInfo>;
    // (undocumented)
    getActiveNetwork(): Promise<INetworkInfo>;
    // (undocumented)
    getNetworks(): Promise<INetworkInfo[]>;
    // (undocumented)
    name: string;
    // (undocumented)
    off(event: string, listener: (...args: any[]) => void): this;
    // (undocumented)
    on(event: string, listener: (...args: any[]) => void): this;
    // (undocumented)
    onAccountChange(cb: (newAccount: IAccountInfo) => void): void;
    // (undocumented)
    onNetworkChange(cb: (newNetwork: INetworkInfo) => void): void;
    // (undocumented)
    request(args: {
        method: string;
        [key: string]: any;
    }): Promise<unknown>;
    // (undocumented)
    signCommand(command: ISigningRequestPartial | IUnsignedCommand): Promise<ICommand | IUnsignedCommand>;
    // (undocumented)
    signTransaction(transaction: IUnsignedCommand | IUnsignedCommand[]): Promise<(IUnsignedCommand | ICommand) | (IUnsignedCommand | ICommand)[]>;
}

// @public (undocumented)
export interface IAdapterFactoryData {
    // (undocumented)
    detected: boolean;
    // (undocumented)
    name: string;
}

// @public (undocumented)
export interface IBaseWalletAdapterOptions {
    // (undocumented)
    networkId?: string;
    // (undocumented)
    provider: IProvider;
}

// @public (undocumented)
export interface IBaseWalletFactoryOptions {
    // (undocumented)
    networkId?: string;
}

export { ICommand }

// @public (undocumented)
export interface IJsonRpcError {
    // (undocumented)
    error: {
        code: number;
        message: string;
        data?: object;
    };
    // (undocumented)
    id: number;
    // (undocumented)
    jsonrpc: '2.0';
}

// @public (undocumented)
export interface IJsonRpcSuccess<T> {
    // (undocumented)
    id: number;
    // (undocumented)
    jsonrpc: '2.0';
    // (undocumented)
    result: T;
}

// @public (undocumented)
export interface IKdaMethodMap {
    // (undocumented)
    kadena_connect: {
        params: KdaConnectOptions;
        response: JsonRpcResponse<any>;
    };
    // (undocumented)
    kadena_disconnect: {
        params: {
            networkId?: string;
        };
        response: JsonRpcResponse<void>;
    };
    // (undocumented)
    kadena_getAccount_v1: {
        params: {};
        response: JsonRpcResponse<IAccountInfo>;
    };
    // (undocumented)
    kadena_getAccounts_v2: {
        params: {};
        response: JsonRpcResponse<IAccountInfo[]>;
    };
    // (undocumented)
    kadena_getNetwork_v1: {
        params: {};
        response: JsonRpcResponse<INetworkInfo>;
    };
    // (undocumented)
    kadena_getNetworks_v1: {
        params: {};
        response: JsonRpcResponse<INetworkInfo[]>;
    };
    // (undocumented)
    kadena_quicksign_v1: {
        params: {
            commandSigDatas: CommandSigDatas;
        };
        response: JsonRpcResponse<IQuicksignResponse>;
    };
    // (undocumented)
    kadena_sign_v1: {
        params: ISigningRequestPartial;
        response: JsonRpcResponse<{
            body: ICommand | IUnsignedCommand;
            chainId: ChainId;
        }>;
    };
}

export { IKeyPair }

// @public
export interface INetworkInfo {
    // (undocumented)
    networkId: string;
    // (undocumented)
    networkName: string;
    // (undocumented)
    url?: string[];
}

// @public (undocumented)
export interface IProvider {
    // (undocumented)
    off(event: string, listener: (...args: any[]) => void): void;
    // (undocumented)
    on(event: string, listener: (...args: any[]) => void): void;
    // (undocumented)
    request(args: {
        method: string;
        [key: string]: any;
    }): Promise<unknown>;
}

// @public (undocumented)
export const isCapabilityGuard: (guard: Guard) => guard is CapabilityGuard;

// @public
export function isExecCommand(parsedTransaction: IPactCommand): parsedTransaction is IPactCommand & {
    payload: IExecutionPayloadObject;
};

// @public (undocumented)
export type ISigningRequestPartial = {
    caps: ISigningRequest['caps'];
    code: string;
} & Omit<Partial<ISigningRequest>, 'caps' | 'pactCode'>;

// @public (undocumented)
export const isJsonRpcResponse: (response: any) => boolean;

// @public (undocumented)
export const isJsonRpcSuccess: <T>(response: JsonRpcResponse<T>) => response is IJsonRpcSuccess<T>;

// @public (undocumented)
export const isKeySetGuard: (guard: Guard) => guard is KeySet;

// @public (undocumented)
export const isKeySetRefGuard: (guard: Guard) => guard is KeySetRef;

// @public (undocumented)
export const isModuleGuard: (guard: Guard) => guard is ModuleGuard;

// @public (undocumented)
export const isPactGuard: (guard: Guard) => guard is PactGuard;

// @public (undocumented)
export const isUserGuard: (guard: Guard) => guard is UserGuard;

export { IUnsignedCommand }

// @public (undocumented)
export type JsonRpcResponse<T> = IJsonRpcSuccess<T> | IJsonRpcError;

// @public (undocumented)
export type KdaConnectOptions = Record<string, any>;

// @public (undocumented)
export type KdaMethod = keyof IKdaMethodMap;

// @public (undocumented)
export type KdaRequestArgs<M extends KdaMethod> = {
    method: M;
} & {
    params?: IKdaMethodMap[M]['params'];
};

// @public (undocumented)
export type KeySet = {
    keys: string[];
    pred: string;
};

// @public (undocumented)
export type KeySetRef = {
    keysetref: {
        ns?: string;
        ksn: string;
    };
};

// @public (undocumented)
export type ModuleGuard = {
    moduleName: ModuleName;
    name: string;
};

// @public (undocumented)
export type ModuleName = {
    name: string;
    namespace?: string;
};

// @public
export type OptionalKeyPair = Omit<IKeyPair, 'secretKey'> & {
    secretKey?: string;
};

// @public (undocumented)
export type PactGuard = {
    pactId: string;
    name: string;
};

// @public (undocumented)
export type PactValue = PvLiteral | PvList | Guard | PvObject | PvModRef | PvTime | PvCapToken;

// @public
export const parseTransactionCommand: (transaction: IUnsignedCommand | ICommand) => IPactCommand;

// @public
export const prepareQuickSignCmd: (transactionList: IUnsignedCommand | Array<IUnsignedCommand | ICommand>) => Promise<{
    commandSigDatas: {
        cmd: string;
        sigs: {
            pubKey: string;
            sig: string | null;
        }[];
    }[];
    transactionHashes: string[];
    transactions: (IUnsignedCommand | ICommand)[];
    isList: boolean;
}>;

// @public
export function prepareSignCmd(transaction: IUnsignedCommand | ICommand | ISigningRequestPartial): ISigningRequestPartial;

// @public (undocumented)
export type PvCapToken = {
    ctName: string;
    ctArgs: PactValue[];
};

// @public (undocumented)
export type PvDecimal = number | {
    decimal: string;
};

// @public (undocumented)
export type PvInteger = {
    int: number | string;
};

// @public (undocumented)
export type PvList = PactValue[];

// @public (undocumented)
export type PvLiteral = string | PvInteger | PvDecimal | boolean;

// @public (undocumented)
export type PvModRef = {
    refName: string;
    refSpec: ModuleName[];
};

// @public (undocumented)
export type PvObject = {
    [key: string]: PactValue;
};

// @public (undocumented)
export type PvTime = {
    time: string;
} | {
    timep: string;
};

export { StandardSchemaV1 }

// @public (undocumented)
export type UserGuard = {
    fun: string;
    args: PactValue[];
};

// @public
export class WalletAdapterClient {
    constructor(adapters: (IAdapter | AdapterFactory)[]);
    connect(adapterName: IAdapter['name'], params?: unknown): Promise<IAccountInfo | null>;
    disconnect(adapterName: string): Promise<void>;
    getAccounts(adapterName: string): Promise<IAccountInfo[]>;
    getActiveAccount(adapterName: string): Promise<IAccountInfo>;
    getActiveNetwork(adapterName: string): Promise<INetworkInfo>;
    // (undocumented)
    getAdapter(adapterName: string): IAdapter | undefined;
    // (undocumented)
    getDetectedAdapters(): IAdapter[];
    getNetworks(adapterName: string): Promise<INetworkInfo[]>;
    // (undocumented)
    getProviders(): {
        name: string;
        detected: boolean;
    }[];
    // (undocumented)
    init(): Promise<void>;
    // (undocumented)
    isDetected(name: string): boolean;
    onAccountChange(adapterName: string, cb: (newAccount: IAccountInfo) => void): void;
    // (undocumented)
    onAdapterDetected(cb: (adapter: IAdapter) => void, options?: {
        signal?: AbortSignal;
    }): void;
    onNetworkChange(adapterName: string, cb: (newNetwork: INetworkInfo) => void): void;
    request(adapterName: string, args: {
        method: string;
        [key: string]: any;
    }): Promise<unknown>;
    signCommand(adapterName: string, command: ISigningRequestPartial | IUnsignedCommand): Promise<ICommand | IUnsignedCommand>;
    signTransaction(adapterName: string, transaction: IUnsignedCommand | IUnsignedCommand[]): Promise<(IUnsignedCommand | ICommand) | (IUnsignedCommand | ICommand)[]>;
}

// (No @packageDocumentation comment for this package)

```
