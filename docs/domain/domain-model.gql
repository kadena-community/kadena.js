enum DateFormat {
    POSIX_MS
    ISO8601
}

scalar Date
scalar Base64Url # ???
scalar Base64UrlTransaction

type Query {
  block: Block
}

type Signature {
  sig: String
}

# ############################################################################ #
# Chainweb Realm

# Note: this schema is not compatible with the current JSON encoding for `Block`
# and `Cut`.
#
# The current schema uses chain ids as field keys for adjacent blocks (in
# `Block`) and cut hashes (in `Cut`). Numeric field keys are not supported by
# GraphQL. This schema uses arrays instead and includes the chain id key into
# the array items. An alterantive (more verbose but also more type safe) schema
# would use fields names like `CHAIN_0`, `CHAIN_1`, ..., CHAIN_19`.

enum ChainwebNetwork {
  mainnet01
  testnet04
}

# [0,..,19] in the current API
scalar ChainId

# Should an enum be prefered over an scalar?
# enum ChainId_ {
#   CHAIN_0
#   CHAIN_1
#   CHAIN_2
#   CHAIN_3
#   CHAIN_4
#   CHAIN_5
#   CHAIN_6
#   CHAIN_7
#   CHAIN_8
#   CHAIN_9
#   CHAIN_10
#   CHAIN_11
#   CHAIN_12
#   CHAIN_13
#   CHAIN_14
#   CHAIN_15
#   CHAIN_16
#   CHAIN_17
#   CHAIN_18
#   CHAIN_19
# }

# Hashes (32 bytes or 256 bits)
scalar BlockHash
scalar PayloadHash
scalar CutHash
scalar PayloadTransactionsHash
scalar PayloadOutputsHash

# 256 bits (without numerical semantics)
scalar Word64

# Unsigned Integer
scalar BlockHeight

# Unsigned fixed size 256 bit integer
scalar BlockWeight

# the only allowed values for `chain` are the adjacent chains of the chain
# of the block.
type AdjecentBlock {
  chain: ChainId!
  hash: BlockHash!
}

type Block {
  creationTime(format: DateFormat = ISO8601): Date!
  parent: BlockHash!
  height: BlockHeight!
  hash: BlockHash!
  chainId: ChainId!
  weight: BlockWeight!
  featureFlags: Word64!
  epochStart(format: DateFormat = ISO8601): Date!
  adjacent: [AdjecentBlock!]!
  payloadHash: PayloadHash!
  chainwebVersion: ChainwebNetwork!
  target: BlockWeight!
  nonce: Word64!

  # Nullable. The server is free to return null if this data isn't available
  payload: BlockPayload
}

# Cuts

type CutItem {
  chain: ChainId!
  height: BlockHeight!
  hash: BlockHash!
}

# On the P2P API a cut may also contains an optional list of block headers and
# an optiona list of paylaods
type Cut {
  hashes: [CutItem!]! # one items for each chain
  origin: String # Nullable
  weight: BlockWeight!
  height: BlockHeight!
  instance: ChainwebNetwork!
  id: CutHash!
}

# Note that chainweb is agnostic of any types from the pact realm. The current
# API returns those values as binary data (encoded as Base64UrlWithoutPadding
# text in JSON).
#
# This schema breaks this abstraction, by requiring from the service in the
# chainweb realm insights into types from the pact realm.

type BlockPayload {
  transactions: [Transaction!]!
  minerData: Account!
  transactionsHash: PayloadTransactionsHash!
  outputsHash: PayloadOutputsHash!
  payloadHash: PayloadHash!
  coinbase: CoinbaseTransaction!
}

type Transaction {
  command: TransactionCommand!
  # Nullable, because some services may only store transactions, but no outputs
  commandResult: TransactionCommandResult
}

# ############################################################################ #
# Pact Realm

scalar TransactionHash
scalar Object

type CoinbaseTransaction {
  gas: Int
  result: CoinbaseTransactionResult
  reqKey: String
  logs: String
  events: [EventData]
  metaData: undefined
  continuation: undefined
  txId: Int
}

type undefined {
  some: String
}

type CoinbaseTransactionResult {
  status: String
  data: String
}

type Account {
  name: String
  guard: KeySet
}

type EventData {
  some: String
}


type KeySet {
  """
  "keys-all" | "keys-any" | "keys-2"
  """
  predicate: String
  pubKeys: [String]
}

enum KeysetPredicateOptions {
  KeysAllPredicate
  KeysTwoPredicate
  KeysAnyPredicate
}

# Pact realm
type TransactionCommand {
  hash: TransactionHash!
  cmd: TransactionCommandPayload # json "cmd" haskell "payload"
  sigs: [Signature]
}

type TransactionCommandPayload {
  payload: TransactionCommandPayloadPayload
  nonce: String
  meta: TransactionCommandPayloadMeta
  signers: [TransactionSigner]
  networkId: String # chainweb || kuro
}

type TransactionCommandPayloadMeta {
  some: String
  # chainId: Int
  # creationTime: MsFromPosixEpoch
  # ttl: Int
  # gasLimit: Int
  # gasPrice: Int
  # sender: String
  # signer: String
  # nonce: String
}

type TransactionCommandResult {
  some: String
}

type TransactionSigner {
  pubKey: String
  capabilities: [TransactionCapability]
}

type TransactionCapability {
  name: String
  args: [String]
}

union TransactionCommandPayloadPayload =
    TransactionCommandExecutionPayload
  | TransactionCommandContinuationPayload

type TransactionCommandExecutionPayload {
  exec: ExecutionPayload
}

type ExecutionPayload {
  data: Object
  code: String
}

type TransactionCommandContinuationPayload {
  cont: ContinuationPayload
}

type ContinuationPayload {
  proof: String
  pactId: String
  rollback: Boolean # | null
  step: Int
  data: Object
}
